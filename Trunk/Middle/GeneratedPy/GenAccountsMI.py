'''
GenAccountsMI.py
Wed May 11 17:17:20 2005
Generated by MiddleKit.
'''

# MK attribute caches for setFoo() methods
_IDAttr = None
_MitgliedsNrAttr = None
_NeueMitgliedsNrAttr = None
_VornameAttr = None
_NachnameAttr = None
_TitelAttr = None
_AdresszusatzAttr = None
_StrasseAttr = None
_OrtAttr = None
_CountrycodeAttr = None
_PLZAttr = None
_TelefonPrivatAttr = None
_TelefonDienstAttr = None
_MobiltelefonAttr = None
_FAXAttr = None
_EMailAttr = None
_GeburtsdatumAttr = None
_GeschlechtAttr = None
_KontoNr1Attr = None
_BLZ1Attr = None
_Bank1Attr = None
_Kontoinhaber1Attr = None
_KontoNr2Attr = None
_BLZ2Attr = None
_Bank2Attr = None
_Kontoinhaber2Attr = None
_Beitragsart1Attr = None
_BeitragsartAb1Attr = None
_BeitragsartFreiAb1Attr = None
_BeitragsartErhebungAb1Attr = None
_Beitragsart2Attr = None
_BeitragsartAb2Attr = None
_BeitragsartFreiAb2Attr = None
_BeitragsartErhebungAb2Attr = None
_Beitragsart3Attr = None
_BeitragsartAb3Attr = None
_BeitragsartFreiAb3Attr = None
_BeitragsartErhebungAb3Attr = None
_Beitragsart4Attr = None
_BeitragsartAb4Attr = None
_BeitragsartFreiAb4Attr = None
_BeitragsartErhebungAb4Attr = None
_Beitragsart5Attr = None
_BeitragsartAb5Attr = None
_BeitragsartFreiAb5Attr = None
_BeitragsartErhebungAb5Attr = None
_ZahlungsartAttr = None
_LastschriftAbAttr = None
_RechnungAbAttr = None
_EintrittsdatumAttr = None
_AustrittsdatumAttr = None
_AustrittsgrundAttr = None
_ErsteingabeAmAttr = None
_MahnstufeAttr = None
_LetzteMahnungAmAttr = None
_KommentareAttr = None
_FehlercodeAttr = None
_changedOnAttr = None
_changedByAttr = None
_changedAtAttr = None

import types
from mx import DateTime


from MiddleKit.Run.MiddleObject import MiddleObject
from types import InstanceType, LongType



class GenAccountsMI(MiddleObject):

	def __init__(self):
		MiddleObject.__init__(self)
		self._ID                     = None
		self._MitgliedsNr            = None
		self._NeueMitgliedsNr        = None
		self._Vorname                = None
		self._Nachname               = None
		self._Titel                  = None
		self._Adresszusatz           = None
		self._Strasse                = None
		self._Ort                    = None
		self._Countrycode            = None
		self._PLZ                    = None
		self._TelefonPrivat          = None
		self._TelefonDienst          = None
		self._Mobiltelefon           = None
		self._FAX                    = None
		self._EMail                  = None
		self._Geburtsdatum           = None
		self._Geschlecht             = None
		self._KontoNr1               = None
		self._BLZ1                   = None
		self._Bank1                  = None
		self._Kontoinhaber1          = None
		self._KontoNr2               = None
		self._BLZ2                   = None
		self._Bank2                  = None
		self._Kontoinhaber2          = None
		self._Beitragsart1           = None
		self._BeitragsartAb1         = None
		self._BeitragsartFreiAb1     = None
		self._BeitragsartErhebungAb1 = None
		self._Beitragsart2           = None
		self._BeitragsartAb2         = None
		self._BeitragsartFreiAb2     = None
		self._BeitragsartErhebungAb2 = None
		self._Beitragsart3           = None
		self._BeitragsartAb3         = None
		self._BeitragsartFreiAb3     = None
		self._BeitragsartErhebungAb3 = None
		self._Beitragsart4           = None
		self._BeitragsartAb4         = None
		self._BeitragsartFreiAb4     = None
		self._BeitragsartErhebungAb4 = None
		self._Beitragsart5           = None
		self._BeitragsartAb5         = None
		self._BeitragsartFreiAb5     = None
		self._BeitragsartErhebungAb5 = None
		self._Zahlungsart            = None
		self._LastschriftAb          = None
		self._RechnungAb             = None
		self._Eintrittsdatum         = None
		self._Austrittsdatum         = None
		self._Austrittsgrund         = None
		self._ErsteingabeAm          = None
		self._Mahnstufe              = None
		self._LetzteMahnungAm        = None
		self._Kommentare             = None
		self._Fehlercode             = None
		self._changedOn              = None
		self._changedBy              = None
		self._changedAt              = None


	def ID(self):
		return self._ID

	def setID(self, value):
		assert value is not None
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._ID
		self._ID = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _IDAttr
			if _IDAttr is None:
				_IDAttr = self.klass().lookupAttr('ID')
				if not _IDAttr.shouldRegisterChanges():
					_IDAttr = 0
			if _IDAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['ID'] = _IDAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def MitgliedsNr(self):
		return self._MitgliedsNr

	def setMitgliedsNr(self, value):
		assert value is not None
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._MitgliedsNr
		self._MitgliedsNr = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _MitgliedsNrAttr
			if _MitgliedsNrAttr is None:
				_MitgliedsNrAttr = self.klass().lookupAttr('MitgliedsNr')
				if not _MitgliedsNrAttr.shouldRegisterChanges():
					_MitgliedsNrAttr = 0
			if _MitgliedsNrAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['MitgliedsNr'] = _MitgliedsNrAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def NeueMitgliedsNr(self):
		return self._NeueMitgliedsNr

	def setNeueMitgliedsNr(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._NeueMitgliedsNr
		self._NeueMitgliedsNr = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _NeueMitgliedsNrAttr
			if _NeueMitgliedsNrAttr is None:
				_NeueMitgliedsNrAttr = self.klass().lookupAttr('NeueMitgliedsNr')
				if not _NeueMitgliedsNrAttr.shouldRegisterChanges():
					_NeueMitgliedsNrAttr = 0
			if _NeueMitgliedsNrAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['NeueMitgliedsNr'] = _NeueMitgliedsNrAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Vorname(self):
		return self._Vorname

	def setVorname(self, value):
		assert value is not None
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Vorname
		self._Vorname = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _VornameAttr
			if _VornameAttr is None:
				_VornameAttr = self.klass().lookupAttr('Vorname')
				if not _VornameAttr.shouldRegisterChanges():
					_VornameAttr = 0
			if _VornameAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Vorname'] = _VornameAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Nachname(self):
		return self._Nachname

	def setNachname(self, value):
		assert value is not None
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Nachname
		self._Nachname = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _NachnameAttr
			if _NachnameAttr is None:
				_NachnameAttr = self.klass().lookupAttr('Nachname')
				if not _NachnameAttr.shouldRegisterChanges():
					_NachnameAttr = 0
			if _NachnameAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Nachname'] = _NachnameAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Titel(self):
		return self._Titel

	def setTitel(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Titel
		self._Titel = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _TitelAttr
			if _TitelAttr is None:
				_TitelAttr = self.klass().lookupAttr('Titel')
				if not _TitelAttr.shouldRegisterChanges():
					_TitelAttr = 0
			if _TitelAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Titel'] = _TitelAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Adresszusatz(self):
		return self._Adresszusatz

	def setAdresszusatz(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Adresszusatz
		self._Adresszusatz = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _AdresszusatzAttr
			if _AdresszusatzAttr is None:
				_AdresszusatzAttr = self.klass().lookupAttr('Adresszusatz')
				if not _AdresszusatzAttr.shouldRegisterChanges():
					_AdresszusatzAttr = 0
			if _AdresszusatzAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Adresszusatz'] = _AdresszusatzAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Strasse(self):
		return self._Strasse

	def setStrasse(self, value):
		assert value is not None
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Strasse
		self._Strasse = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _StrasseAttr
			if _StrasseAttr is None:
				_StrasseAttr = self.klass().lookupAttr('Strasse')
				if not _StrasseAttr.shouldRegisterChanges():
					_StrasseAttr = 0
			if _StrasseAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Strasse'] = _StrasseAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Ort(self):
		return self._Ort

	def setOrt(self, value):
		assert value is not None
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Ort
		self._Ort = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _OrtAttr
			if _OrtAttr is None:
				_OrtAttr = self.klass().lookupAttr('Ort')
				if not _OrtAttr.shouldRegisterChanges():
					_OrtAttr = 0
			if _OrtAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Ort'] = _OrtAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Countrycode(self):
		return self._Countrycode

	def setCountrycode(self, value):
		assert value is not None
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Countrycode
		self._Countrycode = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _CountrycodeAttr
			if _CountrycodeAttr is None:
				_CountrycodeAttr = self.klass().lookupAttr('Countrycode')
				if not _CountrycodeAttr.shouldRegisterChanges():
					_CountrycodeAttr = 0
			if _CountrycodeAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Countrycode'] = _CountrycodeAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def PLZ(self):
		return self._PLZ

	def setPLZ(self, value):
		assert value is not None
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._PLZ
		self._PLZ = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _PLZAttr
			if _PLZAttr is None:
				_PLZAttr = self.klass().lookupAttr('PLZ')
				if not _PLZAttr.shouldRegisterChanges():
					_PLZAttr = 0
			if _PLZAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['PLZ'] = _PLZAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def TelefonPrivat(self):
		return self._TelefonPrivat

	def setTelefonPrivat(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._TelefonPrivat
		self._TelefonPrivat = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _TelefonPrivatAttr
			if _TelefonPrivatAttr is None:
				_TelefonPrivatAttr = self.klass().lookupAttr('TelefonPrivat')
				if not _TelefonPrivatAttr.shouldRegisterChanges():
					_TelefonPrivatAttr = 0
			if _TelefonPrivatAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['TelefonPrivat'] = _TelefonPrivatAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def TelefonDienst(self):
		return self._TelefonDienst

	def setTelefonDienst(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._TelefonDienst
		self._TelefonDienst = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _TelefonDienstAttr
			if _TelefonDienstAttr is None:
				_TelefonDienstAttr = self.klass().lookupAttr('TelefonDienst')
				if not _TelefonDienstAttr.shouldRegisterChanges():
					_TelefonDienstAttr = 0
			if _TelefonDienstAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['TelefonDienst'] = _TelefonDienstAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Mobiltelefon(self):
		return self._Mobiltelefon

	def setMobiltelefon(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Mobiltelefon
		self._Mobiltelefon = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _MobiltelefonAttr
			if _MobiltelefonAttr is None:
				_MobiltelefonAttr = self.klass().lookupAttr('Mobiltelefon')
				if not _MobiltelefonAttr.shouldRegisterChanges():
					_MobiltelefonAttr = 0
			if _MobiltelefonAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Mobiltelefon'] = _MobiltelefonAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def FAX(self):
		return self._FAX

	def setFAX(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._FAX
		self._FAX = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _FAXAttr
			if _FAXAttr is None:
				_FAXAttr = self.klass().lookupAttr('FAX')
				if not _FAXAttr.shouldRegisterChanges():
					_FAXAttr = 0
			if _FAXAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['FAX'] = _FAXAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def EMail(self):
		return self._EMail

	def setEMail(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._EMail
		self._EMail = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _EMailAttr
			if _EMailAttr is None:
				_EMailAttr = self.klass().lookupAttr('EMail')
				if not _EMailAttr.shouldRegisterChanges():
					_EMailAttr = 0
			if _EMailAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['EMail'] = _EMailAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Geburtsdatum(self):
		return self._Geburtsdatum

	def setGeburtsdatum(self, value):
		assert value is not None
		# have DateTime
		if value is not None:
			if type(value) is not DateTime.DateTimeType:
				raise TypeError, 'expecting date type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Geburtsdatum
		self._Geburtsdatum = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _GeburtsdatumAttr
			if _GeburtsdatumAttr is None:
				_GeburtsdatumAttr = self.klass().lookupAttr('Geburtsdatum')
				if not _GeburtsdatumAttr.shouldRegisterChanges():
					_GeburtsdatumAttr = 0
			if _GeburtsdatumAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Geburtsdatum'] = _GeburtsdatumAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Geschlecht(self):
		return self._Geschlecht

	def setGeschlecht(self, value):
		assert value is not None
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Geschlecht
		self._Geschlecht = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _GeschlechtAttr
			if _GeschlechtAttr is None:
				_GeschlechtAttr = self.klass().lookupAttr('Geschlecht')
				if not _GeschlechtAttr.shouldRegisterChanges():
					_GeschlechtAttr = 0
			if _GeschlechtAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Geschlecht'] = _GeschlechtAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def KontoNr1(self):
		return self._KontoNr1

	def setKontoNr1(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._KontoNr1
		self._KontoNr1 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _KontoNr1Attr
			if _KontoNr1Attr is None:
				_KontoNr1Attr = self.klass().lookupAttr('KontoNr1')
				if not _KontoNr1Attr.shouldRegisterChanges():
					_KontoNr1Attr = 0
			if _KontoNr1Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['KontoNr1'] = _KontoNr1Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def BLZ1(self):
		return self._BLZ1

	def setBLZ1(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._BLZ1
		self._BLZ1 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _BLZ1Attr
			if _BLZ1Attr is None:
				_BLZ1Attr = self.klass().lookupAttr('BLZ1')
				if not _BLZ1Attr.shouldRegisterChanges():
					_BLZ1Attr = 0
			if _BLZ1Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['BLZ1'] = _BLZ1Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Bank1(self):
		return self._Bank1

	def setBank1(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Bank1
		self._Bank1 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _Bank1Attr
			if _Bank1Attr is None:
				_Bank1Attr = self.klass().lookupAttr('Bank1')
				if not _Bank1Attr.shouldRegisterChanges():
					_Bank1Attr = 0
			if _Bank1Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Bank1'] = _Bank1Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Kontoinhaber1(self):
		return self._Kontoinhaber1

	def setKontoinhaber1(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Kontoinhaber1
		self._Kontoinhaber1 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _Kontoinhaber1Attr
			if _Kontoinhaber1Attr is None:
				_Kontoinhaber1Attr = self.klass().lookupAttr('Kontoinhaber1')
				if not _Kontoinhaber1Attr.shouldRegisterChanges():
					_Kontoinhaber1Attr = 0
			if _Kontoinhaber1Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Kontoinhaber1'] = _Kontoinhaber1Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def KontoNr2(self):
		return self._KontoNr2

	def setKontoNr2(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._KontoNr2
		self._KontoNr2 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _KontoNr2Attr
			if _KontoNr2Attr is None:
				_KontoNr2Attr = self.klass().lookupAttr('KontoNr2')
				if not _KontoNr2Attr.shouldRegisterChanges():
					_KontoNr2Attr = 0
			if _KontoNr2Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['KontoNr2'] = _KontoNr2Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def BLZ2(self):
		return self._BLZ2

	def setBLZ2(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._BLZ2
		self._BLZ2 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _BLZ2Attr
			if _BLZ2Attr is None:
				_BLZ2Attr = self.klass().lookupAttr('BLZ2')
				if not _BLZ2Attr.shouldRegisterChanges():
					_BLZ2Attr = 0
			if _BLZ2Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['BLZ2'] = _BLZ2Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Bank2(self):
		return self._Bank2

	def setBank2(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Bank2
		self._Bank2 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _Bank2Attr
			if _Bank2Attr is None:
				_Bank2Attr = self.klass().lookupAttr('Bank2')
				if not _Bank2Attr.shouldRegisterChanges():
					_Bank2Attr = 0
			if _Bank2Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Bank2'] = _Bank2Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Kontoinhaber2(self):
		return self._Kontoinhaber2

	def setKontoinhaber2(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Kontoinhaber2
		self._Kontoinhaber2 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _Kontoinhaber2Attr
			if _Kontoinhaber2Attr is None:
				_Kontoinhaber2Attr = self.klass().lookupAttr('Kontoinhaber2')
				if not _Kontoinhaber2Attr.shouldRegisterChanges():
					_Kontoinhaber2Attr = 0
			if _Kontoinhaber2Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Kontoinhaber2'] = _Kontoinhaber2Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Beitragsart1(self):
		return self._Beitragsart1

	def setBeitragsart1(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Beitragsart1
		self._Beitragsart1 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _Beitragsart1Attr
			if _Beitragsart1Attr is None:
				_Beitragsart1Attr = self.klass().lookupAttr('Beitragsart1')
				if not _Beitragsart1Attr.shouldRegisterChanges():
					_Beitragsart1Attr = 0
			if _Beitragsart1Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Beitragsart1'] = _Beitragsart1Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def BeitragsartAb1(self):
		return self._BeitragsartAb1

	def setBeitragsartAb1(self, value):
		# have DateTime
		if value is not None:
			if type(value) is not DateTime.DateTimeType:
				raise TypeError, 'expecting date type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._BeitragsartAb1
		self._BeitragsartAb1 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _BeitragsartAb1Attr
			if _BeitragsartAb1Attr is None:
				_BeitragsartAb1Attr = self.klass().lookupAttr('BeitragsartAb1')
				if not _BeitragsartAb1Attr.shouldRegisterChanges():
					_BeitragsartAb1Attr = 0
			if _BeitragsartAb1Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['BeitragsartAb1'] = _BeitragsartAb1Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def BeitragsartFreiAb1(self):
		return self._BeitragsartFreiAb1

	def setBeitragsartFreiAb1(self, value):
		# have DateTime
		if value is not None:
			if type(value) is not DateTime.DateTimeType:
				raise TypeError, 'expecting date type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._BeitragsartFreiAb1
		self._BeitragsartFreiAb1 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _BeitragsartFreiAb1Attr
			if _BeitragsartFreiAb1Attr is None:
				_BeitragsartFreiAb1Attr = self.klass().lookupAttr('BeitragsartFreiAb1')
				if not _BeitragsartFreiAb1Attr.shouldRegisterChanges():
					_BeitragsartFreiAb1Attr = 0
			if _BeitragsartFreiAb1Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['BeitragsartFreiAb1'] = _BeitragsartFreiAb1Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def BeitragsartErhebungAb1(self):
		return self._BeitragsartErhebungAb1

	def setBeitragsartErhebungAb1(self, value):
		# have DateTime
		if value is not None:
			if type(value) is not DateTime.DateTimeType:
				raise TypeError, 'expecting date type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._BeitragsartErhebungAb1
		self._BeitragsartErhebungAb1 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _BeitragsartErhebungAb1Attr
			if _BeitragsartErhebungAb1Attr is None:
				_BeitragsartErhebungAb1Attr = self.klass().lookupAttr('BeitragsartErhebungAb1')
				if not _BeitragsartErhebungAb1Attr.shouldRegisterChanges():
					_BeitragsartErhebungAb1Attr = 0
			if _BeitragsartErhebungAb1Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['BeitragsartErhebungAb1'] = _BeitragsartErhebungAb1Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Beitragsart2(self):
		return self._Beitragsart2

	def setBeitragsart2(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Beitragsart2
		self._Beitragsart2 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _Beitragsart2Attr
			if _Beitragsart2Attr is None:
				_Beitragsart2Attr = self.klass().lookupAttr('Beitragsart2')
				if not _Beitragsart2Attr.shouldRegisterChanges():
					_Beitragsart2Attr = 0
			if _Beitragsart2Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Beitragsart2'] = _Beitragsart2Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def BeitragsartAb2(self):
		return self._BeitragsartAb2

	def setBeitragsartAb2(self, value):
		# have DateTime
		if value is not None:
			if type(value) is not DateTime.DateTimeType:
				raise TypeError, 'expecting date type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._BeitragsartAb2
		self._BeitragsartAb2 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _BeitragsartAb2Attr
			if _BeitragsartAb2Attr is None:
				_BeitragsartAb2Attr = self.klass().lookupAttr('BeitragsartAb2')
				if not _BeitragsartAb2Attr.shouldRegisterChanges():
					_BeitragsartAb2Attr = 0
			if _BeitragsartAb2Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['BeitragsartAb2'] = _BeitragsartAb2Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def BeitragsartFreiAb2(self):
		return self._BeitragsartFreiAb2

	def setBeitragsartFreiAb2(self, value):
		# have DateTime
		if value is not None:
			if type(value) is not DateTime.DateTimeType:
				raise TypeError, 'expecting date type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._BeitragsartFreiAb2
		self._BeitragsartFreiAb2 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _BeitragsartFreiAb2Attr
			if _BeitragsartFreiAb2Attr is None:
				_BeitragsartFreiAb2Attr = self.klass().lookupAttr('BeitragsartFreiAb2')
				if not _BeitragsartFreiAb2Attr.shouldRegisterChanges():
					_BeitragsartFreiAb2Attr = 0
			if _BeitragsartFreiAb2Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['BeitragsartFreiAb2'] = _BeitragsartFreiAb2Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def BeitragsartErhebungAb2(self):
		return self._BeitragsartErhebungAb2

	def setBeitragsartErhebungAb2(self, value):
		# have DateTime
		if value is not None:
			if type(value) is not DateTime.DateTimeType:
				raise TypeError, 'expecting date type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._BeitragsartErhebungAb2
		self._BeitragsartErhebungAb2 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _BeitragsartErhebungAb2Attr
			if _BeitragsartErhebungAb2Attr is None:
				_BeitragsartErhebungAb2Attr = self.klass().lookupAttr('BeitragsartErhebungAb2')
				if not _BeitragsartErhebungAb2Attr.shouldRegisterChanges():
					_BeitragsartErhebungAb2Attr = 0
			if _BeitragsartErhebungAb2Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['BeitragsartErhebungAb2'] = _BeitragsartErhebungAb2Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Beitragsart3(self):
		return self._Beitragsart3

	def setBeitragsart3(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Beitragsart3
		self._Beitragsart3 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _Beitragsart3Attr
			if _Beitragsart3Attr is None:
				_Beitragsart3Attr = self.klass().lookupAttr('Beitragsart3')
				if not _Beitragsart3Attr.shouldRegisterChanges():
					_Beitragsart3Attr = 0
			if _Beitragsart3Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Beitragsart3'] = _Beitragsart3Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def BeitragsartAb3(self):
		return self._BeitragsartAb3

	def setBeitragsartAb3(self, value):
		# have DateTime
		if value is not None:
			if type(value) is not DateTime.DateTimeType:
				raise TypeError, 'expecting date type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._BeitragsartAb3
		self._BeitragsartAb3 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _BeitragsartAb3Attr
			if _BeitragsartAb3Attr is None:
				_BeitragsartAb3Attr = self.klass().lookupAttr('BeitragsartAb3')
				if not _BeitragsartAb3Attr.shouldRegisterChanges():
					_BeitragsartAb3Attr = 0
			if _BeitragsartAb3Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['BeitragsartAb3'] = _BeitragsartAb3Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def BeitragsartFreiAb3(self):
		return self._BeitragsartFreiAb3

	def setBeitragsartFreiAb3(self, value):
		# have DateTime
		if value is not None:
			if type(value) is not DateTime.DateTimeType:
				raise TypeError, 'expecting date type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._BeitragsartFreiAb3
		self._BeitragsartFreiAb3 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _BeitragsartFreiAb3Attr
			if _BeitragsartFreiAb3Attr is None:
				_BeitragsartFreiAb3Attr = self.klass().lookupAttr('BeitragsartFreiAb3')
				if not _BeitragsartFreiAb3Attr.shouldRegisterChanges():
					_BeitragsartFreiAb3Attr = 0
			if _BeitragsartFreiAb3Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['BeitragsartFreiAb3'] = _BeitragsartFreiAb3Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def BeitragsartErhebungAb3(self):
		return self._BeitragsartErhebungAb3

	def setBeitragsartErhebungAb3(self, value):
		# have DateTime
		if value is not None:
			if type(value) is not DateTime.DateTimeType:
				raise TypeError, 'expecting date type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._BeitragsartErhebungAb3
		self._BeitragsartErhebungAb3 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _BeitragsartErhebungAb3Attr
			if _BeitragsartErhebungAb3Attr is None:
				_BeitragsartErhebungAb3Attr = self.klass().lookupAttr('BeitragsartErhebungAb3')
				if not _BeitragsartErhebungAb3Attr.shouldRegisterChanges():
					_BeitragsartErhebungAb3Attr = 0
			if _BeitragsartErhebungAb3Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['BeitragsartErhebungAb3'] = _BeitragsartErhebungAb3Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Beitragsart4(self):
		return self._Beitragsart4

	def setBeitragsart4(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Beitragsart4
		self._Beitragsart4 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _Beitragsart4Attr
			if _Beitragsart4Attr is None:
				_Beitragsart4Attr = self.klass().lookupAttr('Beitragsart4')
				if not _Beitragsart4Attr.shouldRegisterChanges():
					_Beitragsart4Attr = 0
			if _Beitragsart4Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Beitragsart4'] = _Beitragsart4Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def BeitragsartAb4(self):
		return self._BeitragsartAb4

	def setBeitragsartAb4(self, value):
		# have DateTime
		if value is not None:
			if type(value) is not DateTime.DateTimeType:
				raise TypeError, 'expecting date type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._BeitragsartAb4
		self._BeitragsartAb4 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _BeitragsartAb4Attr
			if _BeitragsartAb4Attr is None:
				_BeitragsartAb4Attr = self.klass().lookupAttr('BeitragsartAb4')
				if not _BeitragsartAb4Attr.shouldRegisterChanges():
					_BeitragsartAb4Attr = 0
			if _BeitragsartAb4Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['BeitragsartAb4'] = _BeitragsartAb4Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def BeitragsartFreiAb4(self):
		return self._BeitragsartFreiAb4

	def setBeitragsartFreiAb4(self, value):
		# have DateTime
		if value is not None:
			if type(value) is not DateTime.DateTimeType:
				raise TypeError, 'expecting date type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._BeitragsartFreiAb4
		self._BeitragsartFreiAb4 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _BeitragsartFreiAb4Attr
			if _BeitragsartFreiAb4Attr is None:
				_BeitragsartFreiAb4Attr = self.klass().lookupAttr('BeitragsartFreiAb4')
				if not _BeitragsartFreiAb4Attr.shouldRegisterChanges():
					_BeitragsartFreiAb4Attr = 0
			if _BeitragsartFreiAb4Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['BeitragsartFreiAb4'] = _BeitragsartFreiAb4Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def BeitragsartErhebungAb4(self):
		return self._BeitragsartErhebungAb4

	def setBeitragsartErhebungAb4(self, value):
		# have DateTime
		if value is not None:
			if type(value) is not DateTime.DateTimeType:
				raise TypeError, 'expecting date type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._BeitragsartErhebungAb4
		self._BeitragsartErhebungAb4 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _BeitragsartErhebungAb4Attr
			if _BeitragsartErhebungAb4Attr is None:
				_BeitragsartErhebungAb4Attr = self.klass().lookupAttr('BeitragsartErhebungAb4')
				if not _BeitragsartErhebungAb4Attr.shouldRegisterChanges():
					_BeitragsartErhebungAb4Attr = 0
			if _BeitragsartErhebungAb4Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['BeitragsartErhebungAb4'] = _BeitragsartErhebungAb4Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Beitragsart5(self):
		return self._Beitragsart5

	def setBeitragsart5(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Beitragsart5
		self._Beitragsart5 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _Beitragsart5Attr
			if _Beitragsart5Attr is None:
				_Beitragsart5Attr = self.klass().lookupAttr('Beitragsart5')
				if not _Beitragsart5Attr.shouldRegisterChanges():
					_Beitragsart5Attr = 0
			if _Beitragsart5Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Beitragsart5'] = _Beitragsart5Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def BeitragsartAb5(self):
		return self._BeitragsartAb5

	def setBeitragsartAb5(self, value):
		# have DateTime
		if value is not None:
			if type(value) is not DateTime.DateTimeType:
				raise TypeError, 'expecting date type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._BeitragsartAb5
		self._BeitragsartAb5 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _BeitragsartAb5Attr
			if _BeitragsartAb5Attr is None:
				_BeitragsartAb5Attr = self.klass().lookupAttr('BeitragsartAb5')
				if not _BeitragsartAb5Attr.shouldRegisterChanges():
					_BeitragsartAb5Attr = 0
			if _BeitragsartAb5Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['BeitragsartAb5'] = _BeitragsartAb5Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def BeitragsartFreiAb5(self):
		return self._BeitragsartFreiAb5

	def setBeitragsartFreiAb5(self, value):
		# have DateTime
		if value is not None:
			if type(value) is not DateTime.DateTimeType:
				raise TypeError, 'expecting date type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._BeitragsartFreiAb5
		self._BeitragsartFreiAb5 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _BeitragsartFreiAb5Attr
			if _BeitragsartFreiAb5Attr is None:
				_BeitragsartFreiAb5Attr = self.klass().lookupAttr('BeitragsartFreiAb5')
				if not _BeitragsartFreiAb5Attr.shouldRegisterChanges():
					_BeitragsartFreiAb5Attr = 0
			if _BeitragsartFreiAb5Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['BeitragsartFreiAb5'] = _BeitragsartFreiAb5Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def BeitragsartErhebungAb5(self):
		return self._BeitragsartErhebungAb5

	def setBeitragsartErhebungAb5(self, value):
		# have DateTime
		if value is not None:
			if type(value) is not DateTime.DateTimeType:
				raise TypeError, 'expecting date type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._BeitragsartErhebungAb5
		self._BeitragsartErhebungAb5 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _BeitragsartErhebungAb5Attr
			if _BeitragsartErhebungAb5Attr is None:
				_BeitragsartErhebungAb5Attr = self.klass().lookupAttr('BeitragsartErhebungAb5')
				if not _BeitragsartErhebungAb5Attr.shouldRegisterChanges():
					_BeitragsartErhebungAb5Attr = 0
			if _BeitragsartErhebungAb5Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['BeitragsartErhebungAb5'] = _BeitragsartErhebungAb5Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Zahlungsart(self):
		return self._Zahlungsart

	def setZahlungsart(self, value):
		assert value is not None
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Zahlungsart
		self._Zahlungsart = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _ZahlungsartAttr
			if _ZahlungsartAttr is None:
				_ZahlungsartAttr = self.klass().lookupAttr('Zahlungsart')
				if not _ZahlungsartAttr.shouldRegisterChanges():
					_ZahlungsartAttr = 0
			if _ZahlungsartAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Zahlungsart'] = _ZahlungsartAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def LastschriftAb(self):
		return self._LastschriftAb

	def setLastschriftAb(self, value):
		# have DateTime
		if value is not None:
			if type(value) is not DateTime.DateTimeType:
				raise TypeError, 'expecting date type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._LastschriftAb
		self._LastschriftAb = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _LastschriftAbAttr
			if _LastschriftAbAttr is None:
				_LastschriftAbAttr = self.klass().lookupAttr('LastschriftAb')
				if not _LastschriftAbAttr.shouldRegisterChanges():
					_LastschriftAbAttr = 0
			if _LastschriftAbAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['LastschriftAb'] = _LastschriftAbAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def RechnungAb(self):
		return self._RechnungAb

	def setRechnungAb(self, value):
		# have DateTime
		if value is not None:
			if type(value) is not DateTime.DateTimeType:
				raise TypeError, 'expecting date type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._RechnungAb
		self._RechnungAb = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _RechnungAbAttr
			if _RechnungAbAttr is None:
				_RechnungAbAttr = self.klass().lookupAttr('RechnungAb')
				if not _RechnungAbAttr.shouldRegisterChanges():
					_RechnungAbAttr = 0
			if _RechnungAbAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['RechnungAb'] = _RechnungAbAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Eintrittsdatum(self):
		return self._Eintrittsdatum

	def setEintrittsdatum(self, value):
		assert value is not None
		# have DateTime
		if value is not None:
			if type(value) is not DateTime.DateTimeType:
				raise TypeError, 'expecting date type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Eintrittsdatum
		self._Eintrittsdatum = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _EintrittsdatumAttr
			if _EintrittsdatumAttr is None:
				_EintrittsdatumAttr = self.klass().lookupAttr('Eintrittsdatum')
				if not _EintrittsdatumAttr.shouldRegisterChanges():
					_EintrittsdatumAttr = 0
			if _EintrittsdatumAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Eintrittsdatum'] = _EintrittsdatumAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Austrittsdatum(self):
		return self._Austrittsdatum

	def setAustrittsdatum(self, value):
		# have DateTime
		if value is not None:
			if type(value) is not DateTime.DateTimeType:
				raise TypeError, 'expecting date type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Austrittsdatum
		self._Austrittsdatum = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _AustrittsdatumAttr
			if _AustrittsdatumAttr is None:
				_AustrittsdatumAttr = self.klass().lookupAttr('Austrittsdatum')
				if not _AustrittsdatumAttr.shouldRegisterChanges():
					_AustrittsdatumAttr = 0
			if _AustrittsdatumAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Austrittsdatum'] = _AustrittsdatumAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Austrittsgrund(self):
		return self._Austrittsgrund

	def setAustrittsgrund(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Austrittsgrund
		self._Austrittsgrund = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _AustrittsgrundAttr
			if _AustrittsgrundAttr is None:
				_AustrittsgrundAttr = self.klass().lookupAttr('Austrittsgrund')
				if not _AustrittsgrundAttr.shouldRegisterChanges():
					_AustrittsgrundAttr = 0
			if _AustrittsgrundAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Austrittsgrund'] = _AustrittsgrundAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def ErsteingabeAm(self):
		return self._ErsteingabeAm

	def setErsteingabeAm(self, value):
		assert value is not None
		# have DateTime
		if value is not None:
			if type(value) is not DateTime.DateTimeType:
				raise TypeError, 'expecting date type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._ErsteingabeAm
		self._ErsteingabeAm = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _ErsteingabeAmAttr
			if _ErsteingabeAmAttr is None:
				_ErsteingabeAmAttr = self.klass().lookupAttr('ErsteingabeAm')
				if not _ErsteingabeAmAttr.shouldRegisterChanges():
					_ErsteingabeAmAttr = 0
			if _ErsteingabeAmAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['ErsteingabeAm'] = _ErsteingabeAmAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Mahnstufe(self):
		return self._Mahnstufe

	def setMahnstufe(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Mahnstufe
		self._Mahnstufe = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _MahnstufeAttr
			if _MahnstufeAttr is None:
				_MahnstufeAttr = self.klass().lookupAttr('Mahnstufe')
				if not _MahnstufeAttr.shouldRegisterChanges():
					_MahnstufeAttr = 0
			if _MahnstufeAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Mahnstufe'] = _MahnstufeAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def LetzteMahnungAm(self):
		return self._LetzteMahnungAm

	def setLetzteMahnungAm(self, value):
		# have DateTime
		if value is not None:
			if type(value) is not DateTime.DateTimeType:
				raise TypeError, 'expecting date type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._LetzteMahnungAm
		self._LetzteMahnungAm = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _LetzteMahnungAmAttr
			if _LetzteMahnungAmAttr is None:
				_LetzteMahnungAmAttr = self.klass().lookupAttr('LetzteMahnungAm')
				if not _LetzteMahnungAmAttr.shouldRegisterChanges():
					_LetzteMahnungAmAttr = 0
			if _LetzteMahnungAmAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['LetzteMahnungAm'] = _LetzteMahnungAmAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Kommentare(self):
		return self._Kommentare

	def setKommentare(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Kommentare
		self._Kommentare = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _KommentareAttr
			if _KommentareAttr is None:
				_KommentareAttr = self.klass().lookupAttr('Kommentare')
				if not _KommentareAttr.shouldRegisterChanges():
					_KommentareAttr = 0
			if _KommentareAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Kommentare'] = _KommentareAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Fehlercode(self):
		return self._Fehlercode

	def setFehlercode(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Fehlercode
		self._Fehlercode = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _FehlercodeAttr
			if _FehlercodeAttr is None:
				_FehlercodeAttr = self.klass().lookupAttr('Fehlercode')
				if not _FehlercodeAttr.shouldRegisterChanges():
					_FehlercodeAttr = 0
			if _FehlercodeAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Fehlercode'] = _FehlercodeAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def changedOn(self):
		return self._changedOn

	def setChangedOn(self, value):
		assert value is not None
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._changedOn
		self._changedOn = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _changedOnAttr
			if _changedOnAttr is None:
				_changedOnAttr = self.klass().lookupAttr('changedOn')
				if not _changedOnAttr.shouldRegisterChanges():
					_changedOnAttr = 0
			if _changedOnAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['changedOn'] = _changedOnAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def changedBy(self):
		return self._changedBy

	def setChangedBy(self, value):
		assert value is not None
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._changedBy
		self._changedBy = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _changedByAttr
			if _changedByAttr is None:
				_changedByAttr = self.klass().lookupAttr('changedBy')
				if not _changedByAttr.shouldRegisterChanges():
					_changedByAttr = 0
			if _changedByAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['changedBy'] = _changedByAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def changedAt(self):
		return self._changedAt

	def setChangedAt(self, value):
		assert value is not None
		# have DateTime
		if value is not None:
			if type(value) is not DateTime.DateTimeType:
				raise TypeError, 'expecting datetime type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._changedAt
		self._changedAt = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _changedAtAttr
			if _changedAtAttr is None:
				_changedAtAttr = self.klass().lookupAttr('changedAt')
				if not _changedAtAttr.shouldRegisterChanges():
					_changedAtAttr = 0
			if _changedAtAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['changedAt'] = _changedAtAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

