'''
GenAccountsBK.py
Sat Nov 30 12:00:18 2002
Generated by MiddleKit.
'''

# MK attribute caches for setFoo() methods
_IDAttr = None
_BankNrAttr = None
_BankAttr = None
_KontoNrAttr = None
_BLZAttr = None
_AdresszusatzAttr = None
_StrasseAttr = None
_OrtAttr = None
_CountrycodeAttr = None
_PLZAttr = None
_TelefonServiceAttr = None
_AnsprechpartnerAttr = None
_TelefonAnsprechpartnerAttr = None
_FAXAnsprechpartnerAttr = None
_EMailAnsprechpartnerAttr = None
_PINInternetAttr = None
_PINTelefonAttr = None
_BerechtigteAttr = None
_KommentareAttr = None
_ErsteingabeAmAttr = None
_FehlercodeAttr = None
_changedOnAttr = None
_changedByAttr = None
_changedAtAttr = None

import types
from mx import DateTime


from MiddleKit.Run.MiddleObject import MiddleObject
from types import InstanceType, LongType



class GenAccountsBK(MiddleObject):

	def __init__(self):
		MiddleObject.__init__(self)
		self._ID                     = None
		self._BankNr                 = None
		self._Bank                   = None
		self._KontoNr                = None
		self._BLZ                    = None
		self._Adresszusatz           = None
		self._Strasse                = None
		self._Ort                    = None
		self._Countrycode            = None
		self._PLZ                    = None
		self._TelefonService         = None
		self._Ansprechpartner        = None
		self._TelefonAnsprechpartner = None
		self._FAXAnsprechpartner     = None
		self._EMailAnsprechpartner   = None
		self._PINInternet            = None
		self._PINTelefon             = None
		self._Berechtigte            = None
		self._Kommentare             = None
		self._ErsteingabeAm          = None
		self._Fehlercode             = None
		self._changedOn              = None
		self._changedBy              = None
		self._changedAt              = None


	def ID(self):
		return self._ID

	def setID(self, value):
		assert value is not None
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._ID
		self._ID = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _IDAttr
			if _IDAttr is None:
				_IDAttr = self.klass().lookupAttr('ID')
				if not _IDAttr.shouldRegisterChanges():
					_IDAttr = 0
			if _IDAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['ID'] = _IDAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def BankNr(self):
		return self._BankNr

	def setBankNr(self, value):
		assert value is not None
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._BankNr
		self._BankNr = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _BankNrAttr
			if _BankNrAttr is None:
				_BankNrAttr = self.klass().lookupAttr('BankNr')
				if not _BankNrAttr.shouldRegisterChanges():
					_BankNrAttr = 0
			if _BankNrAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['BankNr'] = _BankNrAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Bank(self):
		return self._Bank

	def setBank(self, value):
		assert value is not None
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Bank
		self._Bank = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _BankAttr
			if _BankAttr is None:
				_BankAttr = self.klass().lookupAttr('Bank')
				if not _BankAttr.shouldRegisterChanges():
					_BankAttr = 0
			if _BankAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Bank'] = _BankAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def KontoNr(self):
		return self._KontoNr

	def setKontoNr(self, value):
		assert value is not None
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._KontoNr
		self._KontoNr = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _KontoNrAttr
			if _KontoNrAttr is None:
				_KontoNrAttr = self.klass().lookupAttr('KontoNr')
				if not _KontoNrAttr.shouldRegisterChanges():
					_KontoNrAttr = 0
			if _KontoNrAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['KontoNr'] = _KontoNrAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def BLZ(self):
		return self._BLZ

	def setBLZ(self, value):
		assert value is not None
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._BLZ
		self._BLZ = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _BLZAttr
			if _BLZAttr is None:
				_BLZAttr = self.klass().lookupAttr('BLZ')
				if not _BLZAttr.shouldRegisterChanges():
					_BLZAttr = 0
			if _BLZAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['BLZ'] = _BLZAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Adresszusatz(self):
		return self._Adresszusatz

	def setAdresszusatz(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Adresszusatz
		self._Adresszusatz = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _AdresszusatzAttr
			if _AdresszusatzAttr is None:
				_AdresszusatzAttr = self.klass().lookupAttr('Adresszusatz')
				if not _AdresszusatzAttr.shouldRegisterChanges():
					_AdresszusatzAttr = 0
			if _AdresszusatzAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Adresszusatz'] = _AdresszusatzAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Strasse(self):
		return self._Strasse

	def setStrasse(self, value):
		assert value is not None
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Strasse
		self._Strasse = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _StrasseAttr
			if _StrasseAttr is None:
				_StrasseAttr = self.klass().lookupAttr('Strasse')
				if not _StrasseAttr.shouldRegisterChanges():
					_StrasseAttr = 0
			if _StrasseAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Strasse'] = _StrasseAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Ort(self):
		return self._Ort

	def setOrt(self, value):
		assert value is not None
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Ort
		self._Ort = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _OrtAttr
			if _OrtAttr is None:
				_OrtAttr = self.klass().lookupAttr('Ort')
				if not _OrtAttr.shouldRegisterChanges():
					_OrtAttr = 0
			if _OrtAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Ort'] = _OrtAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Countrycode(self):
		return self._Countrycode

	def setCountrycode(self, value):
		assert value is not None
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Countrycode
		self._Countrycode = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _CountrycodeAttr
			if _CountrycodeAttr is None:
				_CountrycodeAttr = self.klass().lookupAttr('Countrycode')
				if not _CountrycodeAttr.shouldRegisterChanges():
					_CountrycodeAttr = 0
			if _CountrycodeAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Countrycode'] = _CountrycodeAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def PLZ(self):
		return self._PLZ

	def setPLZ(self, value):
		assert value is not None
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._PLZ
		self._PLZ = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _PLZAttr
			if _PLZAttr is None:
				_PLZAttr = self.klass().lookupAttr('PLZ')
				if not _PLZAttr.shouldRegisterChanges():
					_PLZAttr = 0
			if _PLZAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['PLZ'] = _PLZAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def TelefonService(self):
		return self._TelefonService

	def setTelefonService(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._TelefonService
		self._TelefonService = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _TelefonServiceAttr
			if _TelefonServiceAttr is None:
				_TelefonServiceAttr = self.klass().lookupAttr('TelefonService')
				if not _TelefonServiceAttr.shouldRegisterChanges():
					_TelefonServiceAttr = 0
			if _TelefonServiceAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['TelefonService'] = _TelefonServiceAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Ansprechpartner(self):
		return self._Ansprechpartner

	def setAnsprechpartner(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Ansprechpartner
		self._Ansprechpartner = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _AnsprechpartnerAttr
			if _AnsprechpartnerAttr is None:
				_AnsprechpartnerAttr = self.klass().lookupAttr('Ansprechpartner')
				if not _AnsprechpartnerAttr.shouldRegisterChanges():
					_AnsprechpartnerAttr = 0
			if _AnsprechpartnerAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Ansprechpartner'] = _AnsprechpartnerAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def TelefonAnsprechpartner(self):
		return self._TelefonAnsprechpartner

	def setTelefonAnsprechpartner(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._TelefonAnsprechpartner
		self._TelefonAnsprechpartner = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _TelefonAnsprechpartnerAttr
			if _TelefonAnsprechpartnerAttr is None:
				_TelefonAnsprechpartnerAttr = self.klass().lookupAttr('TelefonAnsprechpartner')
				if not _TelefonAnsprechpartnerAttr.shouldRegisterChanges():
					_TelefonAnsprechpartnerAttr = 0
			if _TelefonAnsprechpartnerAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['TelefonAnsprechpartner'] = _TelefonAnsprechpartnerAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def FAXAnsprechpartner(self):
		return self._FAXAnsprechpartner

	def setFAXAnsprechpartner(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._FAXAnsprechpartner
		self._FAXAnsprechpartner = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _FAXAnsprechpartnerAttr
			if _FAXAnsprechpartnerAttr is None:
				_FAXAnsprechpartnerAttr = self.klass().lookupAttr('FAXAnsprechpartner')
				if not _FAXAnsprechpartnerAttr.shouldRegisterChanges():
					_FAXAnsprechpartnerAttr = 0
			if _FAXAnsprechpartnerAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['FAXAnsprechpartner'] = _FAXAnsprechpartnerAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def EMailAnsprechpartner(self):
		return self._EMailAnsprechpartner

	def setEMailAnsprechpartner(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._EMailAnsprechpartner
		self._EMailAnsprechpartner = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _EMailAnsprechpartnerAttr
			if _EMailAnsprechpartnerAttr is None:
				_EMailAnsprechpartnerAttr = self.klass().lookupAttr('EMailAnsprechpartner')
				if not _EMailAnsprechpartnerAttr.shouldRegisterChanges():
					_EMailAnsprechpartnerAttr = 0
			if _EMailAnsprechpartnerAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['EMailAnsprechpartner'] = _EMailAnsprechpartnerAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def PINInternet(self):
		return self._PINInternet

	def setPINInternet(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._PINInternet
		self._PINInternet = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _PINInternetAttr
			if _PINInternetAttr is None:
				_PINInternetAttr = self.klass().lookupAttr('PINInternet')
				if not _PINInternetAttr.shouldRegisterChanges():
					_PINInternetAttr = 0
			if _PINInternetAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['PINInternet'] = _PINInternetAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def PINTelefon(self):
		return self._PINTelefon

	def setPINTelefon(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._PINTelefon
		self._PINTelefon = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _PINTelefonAttr
			if _PINTelefonAttr is None:
				_PINTelefonAttr = self.klass().lookupAttr('PINTelefon')
				if not _PINTelefonAttr.shouldRegisterChanges():
					_PINTelefonAttr = 0
			if _PINTelefonAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['PINTelefon'] = _PINTelefonAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Berechtigte(self):
		return self._Berechtigte

	def setBerechtigte(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Berechtigte
		self._Berechtigte = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _BerechtigteAttr
			if _BerechtigteAttr is None:
				_BerechtigteAttr = self.klass().lookupAttr('Berechtigte')
				if not _BerechtigteAttr.shouldRegisterChanges():
					_BerechtigteAttr = 0
			if _BerechtigteAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Berechtigte'] = _BerechtigteAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Kommentare(self):
		return self._Kommentare

	def setKommentare(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Kommentare
		self._Kommentare = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _KommentareAttr
			if _KommentareAttr is None:
				_KommentareAttr = self.klass().lookupAttr('Kommentare')
				if not _KommentareAttr.shouldRegisterChanges():
					_KommentareAttr = 0
			if _KommentareAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Kommentare'] = _KommentareAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def ErsteingabeAm(self):
		return self._ErsteingabeAm

	def setErsteingabeAm(self, value):
		assert value is not None
		# have DateTime
		if value is not None:
			if type(value) is not DateTime.DateTimeType:
				raise TypeError, 'expecting date type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._ErsteingabeAm
		self._ErsteingabeAm = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _ErsteingabeAmAttr
			if _ErsteingabeAmAttr is None:
				_ErsteingabeAmAttr = self.klass().lookupAttr('ErsteingabeAm')
				if not _ErsteingabeAmAttr.shouldRegisterChanges():
					_ErsteingabeAmAttr = 0
			if _ErsteingabeAmAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['ErsteingabeAm'] = _ErsteingabeAmAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Fehlercode(self):
		return self._Fehlercode

	def setFehlercode(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Fehlercode
		self._Fehlercode = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _FehlercodeAttr
			if _FehlercodeAttr is None:
				_FehlercodeAttr = self.klass().lookupAttr('Fehlercode')
				if not _FehlercodeAttr.shouldRegisterChanges():
					_FehlercodeAttr = 0
			if _FehlercodeAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Fehlercode'] = _FehlercodeAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def changedOn(self):
		return self._changedOn

	def setChangedOn(self, value):
		assert value is not None
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._changedOn
		self._changedOn = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _changedOnAttr
			if _changedOnAttr is None:
				_changedOnAttr = self.klass().lookupAttr('changedOn')
				if not _changedOnAttr.shouldRegisterChanges():
					_changedOnAttr = 0
			if _changedOnAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['changedOn'] = _changedOnAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def changedBy(self):
		return self._changedBy

	def setChangedBy(self, value):
		assert value is not None
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._changedBy
		self._changedBy = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _changedByAttr
			if _changedByAttr is None:
				_changedByAttr = self.klass().lookupAttr('changedBy')
				if not _changedByAttr.shouldRegisterChanges():
					_changedByAttr = 0
			if _changedByAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['changedBy'] = _changedByAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def changedAt(self):
		return self._changedAt

	def setChangedAt(self, value):
		assert value is not None
		# have DateTime
		if value is not None:
			if type(value) is not DateTime.DateTimeType:
				raise TypeError, 'expecting datetime type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._changedAt
		self._changedAt = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _changedAtAttr
			if _changedAtAttr is None:
				_changedAtAttr = self.klass().lookupAttr('changedAt')
				if not _changedAtAttr.shouldRegisterChanges():
					_changedAtAttr = 0
			if _changedAtAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['changedAt'] = _changedAtAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

