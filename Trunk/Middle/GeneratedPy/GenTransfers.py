'''
GenTransfers.py
Sat Nov 30 12:00:18 2002
Generated by MiddleKit.
'''

# MK attribute caches for setFoo() methods
_TAIDAttr = None
_TransferIDAttr = None
_ImportWhoAttr = None
_ImportBeschreibungAttr = None
_BeschreibungAttr = None
_WhoAttr = None
_HabenAttr = None
_SollAttr = None
_Konto1Attr = None
_Konto2Attr = None
_changedByAttr = None
_changedAtAttr = None
_JahrAttr = None
_DatumAttr = None
_BKZAttr = None
_changedOnAttr = None

import types
from mx import DateTime


from MiddleKit.Run.MiddleObject import MiddleObject
from types import InstanceType, LongType



class GenTransfers(MiddleObject):

	def __init__(self):
		MiddleObject.__init__(self)
		self._TAID               = None
		self._TransferID         = None
		self._ImportWho          = None
		self._ImportBeschreibung = None
		self._Beschreibung       = None
		self._Who                = None
		self._Haben              = None
		self._Soll               = None
		self._Konto1             = None
		self._Konto2             = None
		self._changedBy          = None
		self._changedAt          = None
		self._Jahr               = None
		self._Datum              = None
		self._BKZ                = None
		self._changedOn          = None


	def TAID(self):
		return self._TAID

	def setTAID(self, value):
		assert value is not None
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._TAID
		self._TAID = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _TAIDAttr
			if _TAIDAttr is None:
				_TAIDAttr = self.klass().lookupAttr('TAID')
				if not _TAIDAttr.shouldRegisterChanges():
					_TAIDAttr = 0
			if _TAIDAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['TAID'] = _TAIDAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def TransferID(self):
		return self._TransferID

	def setTransferID(self, value):
		assert value is not None
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._TransferID
		self._TransferID = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _TransferIDAttr
			if _TransferIDAttr is None:
				_TransferIDAttr = self.klass().lookupAttr('TransferID')
				if not _TransferIDAttr.shouldRegisterChanges():
					_TransferIDAttr = 0
			if _TransferIDAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['TransferID'] = _TransferIDAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def ImportWho(self):
		return self._ImportWho

	def setImportWho(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._ImportWho
		self._ImportWho = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _ImportWhoAttr
			if _ImportWhoAttr is None:
				_ImportWhoAttr = self.klass().lookupAttr('ImportWho')
				if not _ImportWhoAttr.shouldRegisterChanges():
					_ImportWhoAttr = 0
			if _ImportWhoAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['ImportWho'] = _ImportWhoAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def ImportBeschreibung(self):
		return self._ImportBeschreibung

	def setImportBeschreibung(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._ImportBeschreibung
		self._ImportBeschreibung = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _ImportBeschreibungAttr
			if _ImportBeschreibungAttr is None:
				_ImportBeschreibungAttr = self.klass().lookupAttr('ImportBeschreibung')
				if not _ImportBeschreibungAttr.shouldRegisterChanges():
					_ImportBeschreibungAttr = 0
			if _ImportBeschreibungAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['ImportBeschreibung'] = _ImportBeschreibungAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Beschreibung(self):
		return self._Beschreibung

	def setBeschreibung(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Beschreibung
		self._Beschreibung = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _BeschreibungAttr
			if _BeschreibungAttr is None:
				_BeschreibungAttr = self.klass().lookupAttr('Beschreibung')
				if not _BeschreibungAttr.shouldRegisterChanges():
					_BeschreibungAttr = 0
			if _BeschreibungAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Beschreibung'] = _BeschreibungAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Who(self):
		return self._Who

	def setWho(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Who
		self._Who = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _WhoAttr
			if _WhoAttr is None:
				_WhoAttr = self.klass().lookupAttr('Who')
				if not _WhoAttr.shouldRegisterChanges():
					_WhoAttr = 0
			if _WhoAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Who'] = _WhoAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Haben(self):
		return self._Haben

	def setHaben(self, value):
		if value is not None:
			if type(value) in (types.IntType, types.LongType):
				value = float(value)
			elif type(value) is not types.FloatType:
				raise TypeError, 'expecting float type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Haben
		self._Haben = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _HabenAttr
			if _HabenAttr is None:
				_HabenAttr = self.klass().lookupAttr('Haben')
				if not _HabenAttr.shouldRegisterChanges():
					_HabenAttr = 0
			if _HabenAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Haben'] = _HabenAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Soll(self):
		return self._Soll

	def setSoll(self, value):
		if value is not None:
			if type(value) in (types.IntType, types.LongType):
				value = float(value)
			elif type(value) is not types.FloatType:
				raise TypeError, 'expecting float type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Soll
		self._Soll = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _SollAttr
			if _SollAttr is None:
				_SollAttr = self.klass().lookupAttr('Soll')
				if not _SollAttr.shouldRegisterChanges():
					_SollAttr = 0
			if _SollAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Soll'] = _SollAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Konto1(self):
		return self._Konto1

	def setKonto1(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Konto1
		self._Konto1 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _Konto1Attr
			if _Konto1Attr is None:
				_Konto1Attr = self.klass().lookupAttr('Konto1')
				if not _Konto1Attr.shouldRegisterChanges():
					_Konto1Attr = 0
			if _Konto1Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Konto1'] = _Konto1Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Konto2(self):
		return self._Konto2

	def setKonto2(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Konto2
		self._Konto2 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _Konto2Attr
			if _Konto2Attr is None:
				_Konto2Attr = self.klass().lookupAttr('Konto2')
				if not _Konto2Attr.shouldRegisterChanges():
					_Konto2Attr = 0
			if _Konto2Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Konto2'] = _Konto2Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def changedBy(self):
		return self._changedBy

	def setChangedBy(self, value):
		assert value is not None
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._changedBy
		self._changedBy = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _changedByAttr
			if _changedByAttr is None:
				_changedByAttr = self.klass().lookupAttr('changedBy')
				if not _changedByAttr.shouldRegisterChanges():
					_changedByAttr = 0
			if _changedByAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['changedBy'] = _changedByAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def changedAt(self):
		return self._changedAt

	def setChangedAt(self, value):
		assert value is not None
		# have DateTime
		if value is not None:
			if type(value) is not DateTime.DateTimeType:
				raise TypeError, 'expecting datetime type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._changedAt
		self._changedAt = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _changedAtAttr
			if _changedAtAttr is None:
				_changedAtAttr = self.klass().lookupAttr('changedAt')
				if not _changedAtAttr.shouldRegisterChanges():
					_changedAtAttr = 0
			if _changedAtAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['changedAt'] = _changedAtAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Jahr(self):
		return self._Jahr

	def setJahr(self, value):
		assert value is not None
		if value is not None:
			if type(value) is types.LongType:
				value = int(value)
			elif type(value) is not types.IntType:
				raise TypeError, 'expecting int type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Jahr
		self._Jahr = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _JahrAttr
			if _JahrAttr is None:
				_JahrAttr = self.klass().lookupAttr('Jahr')
				if not _JahrAttr.shouldRegisterChanges():
					_JahrAttr = 0
			if _JahrAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Jahr'] = _JahrAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Datum(self):
		return self._Datum

	def setDatum(self, value):
		# have DateTime
		if value is not None:
			if type(value) is not DateTime.DateTimeType:
				raise TypeError, 'expecting datetime type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Datum
		self._Datum = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _DatumAttr
			if _DatumAttr is None:
				_DatumAttr = self.klass().lookupAttr('Datum')
				if not _DatumAttr.shouldRegisterChanges():
					_DatumAttr = 0
			if _DatumAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Datum'] = _DatumAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def BKZ(self):
		return self._BKZ

	def setBKZ(self, value):
		assert value is not None
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._BKZ
		self._BKZ = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _BKZAttr
			if _BKZAttr is None:
				_BKZAttr = self.klass().lookupAttr('BKZ')
				if not _BKZAttr.shouldRegisterChanges():
					_BKZAttr = 0
			if _BKZAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['BKZ'] = _BKZAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def changedOn(self):
		return self._changedOn

	def setChangedOn(self, value):
		assert value is not None
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._changedOn
		self._changedOn = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _changedOnAttr
			if _changedOnAttr is None:
				_changedOnAttr = self.klass().lookupAttr('changedOn')
				if not _changedOnAttr.shouldRegisterChanges():
					_changedOnAttr = 0
			if _changedOnAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['changedOn'] = _changedOnAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

