'''
GenBLZ.py
Wed May 11 17:17:20 2005
Generated by MiddleKit.
'''

# MK attribute caches for setFoo() methods
_BLZAttr = None
_BankAttr = None
_ChangedOnAttr = None
_ChangedAtAttr = None
_ChangedByAttr = None

import types
from mx import DateTime


from MiddleKit.Run.MiddleObject import MiddleObject
from types import InstanceType, LongType



class GenBLZ(MiddleObject):

	def __init__(self):
		MiddleObject.__init__(self)
		self._BLZ       = None
		self._Bank      = None
		self._ChangedOn = None
		self._ChangedAt = None
		self._ChangedBy = None


	def BLZ(self):
		return self._BLZ

	def setBLZ(self, value):
		assert value is not None
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._BLZ
		self._BLZ = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _BLZAttr
			if _BLZAttr is None:
				_BLZAttr = self.klass().lookupAttr('BLZ')
				if not _BLZAttr.shouldRegisterChanges():
					_BLZAttr = 0
			if _BLZAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['BLZ'] = _BLZAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Bank(self):
		return self._Bank

	def setBank(self, value):
		assert value is not None
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Bank
		self._Bank = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _BankAttr
			if _BankAttr is None:
				_BankAttr = self.klass().lookupAttr('Bank')
				if not _BankAttr.shouldRegisterChanges():
					_BankAttr = 0
			if _BankAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Bank'] = _BankAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def ChangedOn(self):
		return self._ChangedOn

	def setChangedOn(self, value):
		assert value is not None
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._ChangedOn
		self._ChangedOn = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _ChangedOnAttr
			if _ChangedOnAttr is None:
				_ChangedOnAttr = self.klass().lookupAttr('ChangedOn')
				if not _ChangedOnAttr.shouldRegisterChanges():
					_ChangedOnAttr = 0
			if _ChangedOnAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['ChangedOn'] = _ChangedOnAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def ChangedAt(self):
		return self._ChangedAt

	def setChangedAt(self, value):
		assert value is not None
		# have DateTime
		if value is not None:
			if type(value) is not DateTime.DateTimeType:
				raise TypeError, 'expecting datetime type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._ChangedAt
		self._ChangedAt = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _ChangedAtAttr
			if _ChangedAtAttr is None:
				_ChangedAtAttr = self.klass().lookupAttr('ChangedAt')
				if not _ChangedAtAttr.shouldRegisterChanges():
					_ChangedAtAttr = 0
			if _ChangedAtAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['ChangedAt'] = _ChangedAtAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def ChangedBy(self):
		return self._ChangedBy

	def setChangedBy(self, value):
		assert value is not None
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._ChangedBy
		self._ChangedBy = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _ChangedByAttr
			if _ChangedByAttr is None:
				_ChangedByAttr = self.klass().lookupAttr('ChangedBy')
				if not _ChangedByAttr.shouldRegisterChanges():
					_ChangedByAttr = 0
			if _ChangedByAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['ChangedBy'] = _ChangedByAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

