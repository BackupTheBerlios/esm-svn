'''
GenAccountsTR.py
Sat Nov 30 12:00:18 2002
Generated by MiddleKit.
'''

# MK attribute caches for setFoo() methods
_IDAttr = None
_MitgliedsNrAttr = None
_NeueMitgliedsNrAttr = None
_SeitAttr = None
_BisAttr = None
_VornameAttr = None
_NachnameAttr = None
_TitelAttr = None
_AdresszusatzAttr = None
_StrasseAttr = None
_OrtAttr = None
_CountrycodeAttr = None
_PLZAttr = None
_TelefonPrivatAttr = None
_TelefonDienstAttr = None
_MobiltelefonAttr = None
_FAXAttr = None
_EMailAttr = None
_GeburtsdatumAttr = None
_GeschlechtAttr = None
_KontoNr1Attr = None
_BLZ1Attr = None
_Bank1Attr = None
_Kontoinhaber1Attr = None
_KontoNr2Attr = None
_BLZ2Attr = None
_Bank2Attr = None
_Kontoinhaber2Attr = None
_ErsteingabeAmAttr = None
_KommentareAttr = None
_Lizenz1Attr = None
_LizenzNr1Attr = None
_LizenzBis1Attr = None
_LizenzZuschuss1Attr = None
_Lizenz2Attr = None
_LizenzNr2Attr = None
_LizenzBis2Attr = None
_LizenzZuschuss2Attr = None
_Lizenz3Attr = None
_LizenzNr3Attr = None
_LizenzBis3Attr = None
_LizenzZuschuss3Attr = None
_Lizenz4Attr = None
_LizenzNr4Attr = None
_LizenzBis4Attr = None
_LizenzZuschuss4Attr = None
_Lizenz5Attr = None
_LizenzNr5Attr = None
_LizenzBis5Attr = None
_LizenzZuschuss5Attr = None
_Lizenz6Attr = None
_LizenzNr6Attr = None
_LizenzBis6Attr = None
_LizenzZuschuss6Attr = None
_FortbildungenAttr = None
_Honorar1Attr = None
_HonorarBetrag1Attr = None
_Honorar2Attr = None
_HonorarBetrag2Attr = None
_Honorar3Attr = None
_HonorarBetrag3Attr = None
_Honorar4Attr = None
_HonorarBetrag4Attr = None
_Honorar5Attr = None
_HonorarBetrag5Attr = None
_Honorar6Attr = None
_HonorarBetrag6Attr = None
_Training1Attr = None
_TrainingOrt1Attr = None
_TrainingTermin1Attr = None
_Training2Attr = None
_TrainingOrt2Attr = None
_TrainingTermin2Attr = None
_Training3Attr = None
_TrainingOrt3Attr = None
_TrainingTermin3Attr = None
_Training4Attr = None
_TrainingOrt4Attr = None
_TrainingTermin4Attr = None
_Training5Attr = None
_TrainingOrt5Attr = None
_TrainingTermin5Attr = None
_Training6Attr = None
_TrainingOrt6Attr = None
_TrainingTermin6Attr = None
_Training7Attr = None
_TrainingOrt7Attr = None
_TrainingTermin7Attr = None
_Training8Attr = None
_TrainingOrt8Attr = None
_TrainingTermin8Attr = None
_Training9Attr = None
_TrainingOrt9Attr = None
_TrainingTermin9Attr = None
_Training10Attr = None
_TrainingOrt10Attr = None
_TrainingTermin10Attr = None
_FehlercodeAttr = None
_changedOnAttr = None
_changedByAttr = None
_changedAtAttr = None

import types
from mx import DateTime


from MiddleKit.Run.MiddleObject import MiddleObject
from types import InstanceType, LongType



class GenAccountsTR(MiddleObject):

	def __init__(self):
		MiddleObject.__init__(self)
		self._ID               = None
		self._MitgliedsNr      = None
		self._NeueMitgliedsNr  = None
		self._Seit             = None
		self._Bis              = None
		self._Vorname          = None
		self._Nachname         = None
		self._Titel            = None
		self._Adresszusatz     = None
		self._Strasse          = None
		self._Ort              = None
		self._Countrycode      = None
		self._PLZ              = None
		self._TelefonPrivat    = None
		self._TelefonDienst    = None
		self._Mobiltelefon     = None
		self._FAX              = None
		self._EMail            = None
		self._Geburtsdatum     = None
		self._Geschlecht       = None
		self._KontoNr1         = None
		self._BLZ1             = None
		self._Bank1            = None
		self._Kontoinhaber1    = None
		self._KontoNr2         = None
		self._BLZ2             = None
		self._Bank2            = None
		self._Kontoinhaber2    = None
		self._ErsteingabeAm    = None
		self._Kommentare       = None
		self._Lizenz1          = None
		self._LizenzNr1        = None
		self._LizenzBis1       = None
		self._LizenzZuschuss1  = None
		self._Lizenz2          = None
		self._LizenzNr2        = None
		self._LizenzBis2       = None
		self._LizenzZuschuss2  = None
		self._Lizenz3          = None
		self._LizenzNr3        = None
		self._LizenzBis3       = None
		self._LizenzZuschuss3  = None
		self._Lizenz4          = None
		self._LizenzNr4        = None
		self._LizenzBis4       = None
		self._LizenzZuschuss4  = None
		self._Lizenz5          = None
		self._LizenzNr5        = None
		self._LizenzBis5       = None
		self._LizenzZuschuss5  = None
		self._Lizenz6          = None
		self._LizenzNr6        = None
		self._LizenzBis6       = None
		self._LizenzZuschuss6  = None
		self._Fortbildungen    = None
		self._Honorar1         = None
		self._HonorarBetrag1   = None
		self._Honorar2         = None
		self._HonorarBetrag2   = None
		self._Honorar3         = None
		self._HonorarBetrag3   = None
		self._Honorar4         = None
		self._HonorarBetrag4   = None
		self._Honorar5         = None
		self._HonorarBetrag5   = None
		self._Honorar6         = None
		self._HonorarBetrag6   = None
		self._Training1        = None
		self._TrainingOrt1     = None
		self._TrainingTermin1  = None
		self._Training2        = None
		self._TrainingOrt2     = None
		self._TrainingTermin2  = None
		self._Training3        = None
		self._TrainingOrt3     = None
		self._TrainingTermin3  = None
		self._Training4        = None
		self._TrainingOrt4     = None
		self._TrainingTermin4  = None
		self._Training5        = None
		self._TrainingOrt5     = None
		self._TrainingTermin5  = None
		self._Training6        = None
		self._TrainingOrt6     = None
		self._TrainingTermin6  = None
		self._Training7        = None
		self._TrainingOrt7     = None
		self._TrainingTermin7  = None
		self._Training8        = None
		self._TrainingOrt8     = None
		self._TrainingTermin8  = None
		self._Training9        = None
		self._TrainingOrt9     = None
		self._TrainingTermin9  = None
		self._Training10       = None
		self._TrainingOrt10    = None
		self._TrainingTermin10 = None
		self._Fehlercode       = None
		self._changedOn        = None
		self._changedBy        = None
		self._changedAt        = None


	def ID(self):
		return self._ID

	def setID(self, value):
		assert value is not None
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._ID
		self._ID = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _IDAttr
			if _IDAttr is None:
				_IDAttr = self.klass().lookupAttr('ID')
				if not _IDAttr.shouldRegisterChanges():
					_IDAttr = 0
			if _IDAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['ID'] = _IDAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def MitgliedsNr(self):
		return self._MitgliedsNr

	def setMitgliedsNr(self, value):
		assert value is not None
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._MitgliedsNr
		self._MitgliedsNr = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _MitgliedsNrAttr
			if _MitgliedsNrAttr is None:
				_MitgliedsNrAttr = self.klass().lookupAttr('MitgliedsNr')
				if not _MitgliedsNrAttr.shouldRegisterChanges():
					_MitgliedsNrAttr = 0
			if _MitgliedsNrAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['MitgliedsNr'] = _MitgliedsNrAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def NeueMitgliedsNr(self):
		return self._NeueMitgliedsNr

	def setNeueMitgliedsNr(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._NeueMitgliedsNr
		self._NeueMitgliedsNr = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _NeueMitgliedsNrAttr
			if _NeueMitgliedsNrAttr is None:
				_NeueMitgliedsNrAttr = self.klass().lookupAttr('NeueMitgliedsNr')
				if not _NeueMitgliedsNrAttr.shouldRegisterChanges():
					_NeueMitgliedsNrAttr = 0
			if _NeueMitgliedsNrAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['NeueMitgliedsNr'] = _NeueMitgliedsNrAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Seit(self):
		return self._Seit

	def setSeit(self, value):
		assert value is not None
		# have DateTime
		if value is not None:
			if type(value) is not DateTime.DateTimeType:
				raise TypeError, 'expecting date type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Seit
		self._Seit = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _SeitAttr
			if _SeitAttr is None:
				_SeitAttr = self.klass().lookupAttr('Seit')
				if not _SeitAttr.shouldRegisterChanges():
					_SeitAttr = 0
			if _SeitAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Seit'] = _SeitAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Bis(self):
		return self._Bis

	def setBis(self, value):
		# have DateTime
		if value is not None:
			if type(value) is not DateTime.DateTimeType:
				raise TypeError, 'expecting date type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Bis
		self._Bis = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _BisAttr
			if _BisAttr is None:
				_BisAttr = self.klass().lookupAttr('Bis')
				if not _BisAttr.shouldRegisterChanges():
					_BisAttr = 0
			if _BisAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Bis'] = _BisAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Vorname(self):
		return self._Vorname

	def setVorname(self, value):
		assert value is not None
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Vorname
		self._Vorname = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _VornameAttr
			if _VornameAttr is None:
				_VornameAttr = self.klass().lookupAttr('Vorname')
				if not _VornameAttr.shouldRegisterChanges():
					_VornameAttr = 0
			if _VornameAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Vorname'] = _VornameAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Nachname(self):
		return self._Nachname

	def setNachname(self, value):
		assert value is not None
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Nachname
		self._Nachname = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _NachnameAttr
			if _NachnameAttr is None:
				_NachnameAttr = self.klass().lookupAttr('Nachname')
				if not _NachnameAttr.shouldRegisterChanges():
					_NachnameAttr = 0
			if _NachnameAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Nachname'] = _NachnameAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Titel(self):
		return self._Titel

	def setTitel(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Titel
		self._Titel = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _TitelAttr
			if _TitelAttr is None:
				_TitelAttr = self.klass().lookupAttr('Titel')
				if not _TitelAttr.shouldRegisterChanges():
					_TitelAttr = 0
			if _TitelAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Titel'] = _TitelAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Adresszusatz(self):
		return self._Adresszusatz

	def setAdresszusatz(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Adresszusatz
		self._Adresszusatz = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _AdresszusatzAttr
			if _AdresszusatzAttr is None:
				_AdresszusatzAttr = self.klass().lookupAttr('Adresszusatz')
				if not _AdresszusatzAttr.shouldRegisterChanges():
					_AdresszusatzAttr = 0
			if _AdresszusatzAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Adresszusatz'] = _AdresszusatzAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Strasse(self):
		return self._Strasse

	def setStrasse(self, value):
		assert value is not None
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Strasse
		self._Strasse = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _StrasseAttr
			if _StrasseAttr is None:
				_StrasseAttr = self.klass().lookupAttr('Strasse')
				if not _StrasseAttr.shouldRegisterChanges():
					_StrasseAttr = 0
			if _StrasseAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Strasse'] = _StrasseAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Ort(self):
		return self._Ort

	def setOrt(self, value):
		assert value is not None
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Ort
		self._Ort = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _OrtAttr
			if _OrtAttr is None:
				_OrtAttr = self.klass().lookupAttr('Ort')
				if not _OrtAttr.shouldRegisterChanges():
					_OrtAttr = 0
			if _OrtAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Ort'] = _OrtAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Countrycode(self):
		return self._Countrycode

	def setCountrycode(self, value):
		assert value is not None
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Countrycode
		self._Countrycode = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _CountrycodeAttr
			if _CountrycodeAttr is None:
				_CountrycodeAttr = self.klass().lookupAttr('Countrycode')
				if not _CountrycodeAttr.shouldRegisterChanges():
					_CountrycodeAttr = 0
			if _CountrycodeAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Countrycode'] = _CountrycodeAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def PLZ(self):
		return self._PLZ

	def setPLZ(self, value):
		assert value is not None
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._PLZ
		self._PLZ = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _PLZAttr
			if _PLZAttr is None:
				_PLZAttr = self.klass().lookupAttr('PLZ')
				if not _PLZAttr.shouldRegisterChanges():
					_PLZAttr = 0
			if _PLZAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['PLZ'] = _PLZAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def TelefonPrivat(self):
		return self._TelefonPrivat

	def setTelefonPrivat(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._TelefonPrivat
		self._TelefonPrivat = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _TelefonPrivatAttr
			if _TelefonPrivatAttr is None:
				_TelefonPrivatAttr = self.klass().lookupAttr('TelefonPrivat')
				if not _TelefonPrivatAttr.shouldRegisterChanges():
					_TelefonPrivatAttr = 0
			if _TelefonPrivatAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['TelefonPrivat'] = _TelefonPrivatAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def TelefonDienst(self):
		return self._TelefonDienst

	def setTelefonDienst(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._TelefonDienst
		self._TelefonDienst = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _TelefonDienstAttr
			if _TelefonDienstAttr is None:
				_TelefonDienstAttr = self.klass().lookupAttr('TelefonDienst')
				if not _TelefonDienstAttr.shouldRegisterChanges():
					_TelefonDienstAttr = 0
			if _TelefonDienstAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['TelefonDienst'] = _TelefonDienstAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Mobiltelefon(self):
		return self._Mobiltelefon

	def setMobiltelefon(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Mobiltelefon
		self._Mobiltelefon = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _MobiltelefonAttr
			if _MobiltelefonAttr is None:
				_MobiltelefonAttr = self.klass().lookupAttr('Mobiltelefon')
				if not _MobiltelefonAttr.shouldRegisterChanges():
					_MobiltelefonAttr = 0
			if _MobiltelefonAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Mobiltelefon'] = _MobiltelefonAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def FAX(self):
		return self._FAX

	def setFAX(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._FAX
		self._FAX = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _FAXAttr
			if _FAXAttr is None:
				_FAXAttr = self.klass().lookupAttr('FAX')
				if not _FAXAttr.shouldRegisterChanges():
					_FAXAttr = 0
			if _FAXAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['FAX'] = _FAXAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def EMail(self):
		return self._EMail

	def setEMail(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._EMail
		self._EMail = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _EMailAttr
			if _EMailAttr is None:
				_EMailAttr = self.klass().lookupAttr('EMail')
				if not _EMailAttr.shouldRegisterChanges():
					_EMailAttr = 0
			if _EMailAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['EMail'] = _EMailAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Geburtsdatum(self):
		return self._Geburtsdatum

	def setGeburtsdatum(self, value):
		assert value is not None
		# have DateTime
		if value is not None:
			if type(value) is not DateTime.DateTimeType:
				raise TypeError, 'expecting date type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Geburtsdatum
		self._Geburtsdatum = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _GeburtsdatumAttr
			if _GeburtsdatumAttr is None:
				_GeburtsdatumAttr = self.klass().lookupAttr('Geburtsdatum')
				if not _GeburtsdatumAttr.shouldRegisterChanges():
					_GeburtsdatumAttr = 0
			if _GeburtsdatumAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Geburtsdatum'] = _GeburtsdatumAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Geschlecht(self):
		return self._Geschlecht

	def setGeschlecht(self, value):
		assert value is not None
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Geschlecht
		self._Geschlecht = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _GeschlechtAttr
			if _GeschlechtAttr is None:
				_GeschlechtAttr = self.klass().lookupAttr('Geschlecht')
				if not _GeschlechtAttr.shouldRegisterChanges():
					_GeschlechtAttr = 0
			if _GeschlechtAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Geschlecht'] = _GeschlechtAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def KontoNr1(self):
		return self._KontoNr1

	def setKontoNr1(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._KontoNr1
		self._KontoNr1 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _KontoNr1Attr
			if _KontoNr1Attr is None:
				_KontoNr1Attr = self.klass().lookupAttr('KontoNr1')
				if not _KontoNr1Attr.shouldRegisterChanges():
					_KontoNr1Attr = 0
			if _KontoNr1Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['KontoNr1'] = _KontoNr1Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def BLZ1(self):
		return self._BLZ1

	def setBLZ1(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._BLZ1
		self._BLZ1 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _BLZ1Attr
			if _BLZ1Attr is None:
				_BLZ1Attr = self.klass().lookupAttr('BLZ1')
				if not _BLZ1Attr.shouldRegisterChanges():
					_BLZ1Attr = 0
			if _BLZ1Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['BLZ1'] = _BLZ1Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Bank1(self):
		return self._Bank1

	def setBank1(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Bank1
		self._Bank1 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _Bank1Attr
			if _Bank1Attr is None:
				_Bank1Attr = self.klass().lookupAttr('Bank1')
				if not _Bank1Attr.shouldRegisterChanges():
					_Bank1Attr = 0
			if _Bank1Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Bank1'] = _Bank1Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Kontoinhaber1(self):
		return self._Kontoinhaber1

	def setKontoinhaber1(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Kontoinhaber1
		self._Kontoinhaber1 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _Kontoinhaber1Attr
			if _Kontoinhaber1Attr is None:
				_Kontoinhaber1Attr = self.klass().lookupAttr('Kontoinhaber1')
				if not _Kontoinhaber1Attr.shouldRegisterChanges():
					_Kontoinhaber1Attr = 0
			if _Kontoinhaber1Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Kontoinhaber1'] = _Kontoinhaber1Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def KontoNr2(self):
		return self._KontoNr2

	def setKontoNr2(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._KontoNr2
		self._KontoNr2 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _KontoNr2Attr
			if _KontoNr2Attr is None:
				_KontoNr2Attr = self.klass().lookupAttr('KontoNr2')
				if not _KontoNr2Attr.shouldRegisterChanges():
					_KontoNr2Attr = 0
			if _KontoNr2Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['KontoNr2'] = _KontoNr2Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def BLZ2(self):
		return self._BLZ2

	def setBLZ2(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._BLZ2
		self._BLZ2 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _BLZ2Attr
			if _BLZ2Attr is None:
				_BLZ2Attr = self.klass().lookupAttr('BLZ2')
				if not _BLZ2Attr.shouldRegisterChanges():
					_BLZ2Attr = 0
			if _BLZ2Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['BLZ2'] = _BLZ2Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Bank2(self):
		return self._Bank2

	def setBank2(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Bank2
		self._Bank2 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _Bank2Attr
			if _Bank2Attr is None:
				_Bank2Attr = self.klass().lookupAttr('Bank2')
				if not _Bank2Attr.shouldRegisterChanges():
					_Bank2Attr = 0
			if _Bank2Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Bank2'] = _Bank2Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Kontoinhaber2(self):
		return self._Kontoinhaber2

	def setKontoinhaber2(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Kontoinhaber2
		self._Kontoinhaber2 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _Kontoinhaber2Attr
			if _Kontoinhaber2Attr is None:
				_Kontoinhaber2Attr = self.klass().lookupAttr('Kontoinhaber2')
				if not _Kontoinhaber2Attr.shouldRegisterChanges():
					_Kontoinhaber2Attr = 0
			if _Kontoinhaber2Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Kontoinhaber2'] = _Kontoinhaber2Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def ErsteingabeAm(self):
		return self._ErsteingabeAm

	def setErsteingabeAm(self, value):
		assert value is not None
		# have DateTime
		if value is not None:
			if type(value) is not DateTime.DateTimeType:
				raise TypeError, 'expecting date type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._ErsteingabeAm
		self._ErsteingabeAm = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _ErsteingabeAmAttr
			if _ErsteingabeAmAttr is None:
				_ErsteingabeAmAttr = self.klass().lookupAttr('ErsteingabeAm')
				if not _ErsteingabeAmAttr.shouldRegisterChanges():
					_ErsteingabeAmAttr = 0
			if _ErsteingabeAmAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['ErsteingabeAm'] = _ErsteingabeAmAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Kommentare(self):
		return self._Kommentare

	def setKommentare(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Kommentare
		self._Kommentare = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _KommentareAttr
			if _KommentareAttr is None:
				_KommentareAttr = self.klass().lookupAttr('Kommentare')
				if not _KommentareAttr.shouldRegisterChanges():
					_KommentareAttr = 0
			if _KommentareAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Kommentare'] = _KommentareAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Lizenz1(self):
		return self._Lizenz1

	def setLizenz1(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Lizenz1
		self._Lizenz1 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _Lizenz1Attr
			if _Lizenz1Attr is None:
				_Lizenz1Attr = self.klass().lookupAttr('Lizenz1')
				if not _Lizenz1Attr.shouldRegisterChanges():
					_Lizenz1Attr = 0
			if _Lizenz1Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Lizenz1'] = _Lizenz1Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def LizenzNr1(self):
		return self._LizenzNr1

	def setLizenzNr1(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._LizenzNr1
		self._LizenzNr1 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _LizenzNr1Attr
			if _LizenzNr1Attr is None:
				_LizenzNr1Attr = self.klass().lookupAttr('LizenzNr1')
				if not _LizenzNr1Attr.shouldRegisterChanges():
					_LizenzNr1Attr = 0
			if _LizenzNr1Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['LizenzNr1'] = _LizenzNr1Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def LizenzBis1(self):
		return self._LizenzBis1

	def setLizenzBis1(self, value):
		# have DateTime
		if value is not None:
			if type(value) is not DateTime.DateTimeType:
				raise TypeError, 'expecting date type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._LizenzBis1
		self._LizenzBis1 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _LizenzBis1Attr
			if _LizenzBis1Attr is None:
				_LizenzBis1Attr = self.klass().lookupAttr('LizenzBis1')
				if not _LizenzBis1Attr.shouldRegisterChanges():
					_LizenzBis1Attr = 0
			if _LizenzBis1Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['LizenzBis1'] = _LizenzBis1Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def LizenzZuschuss1(self):
		return self._LizenzZuschuss1

	def setLizenzZuschuss1(self, value):
		if value is not None:
			if type(value) in (types.IntType, types.LongType):
				value = float(value)
			elif type(value) is not types.FloatType:
				raise TypeError, 'expecting float type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._LizenzZuschuss1
		self._LizenzZuschuss1 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _LizenzZuschuss1Attr
			if _LizenzZuschuss1Attr is None:
				_LizenzZuschuss1Attr = self.klass().lookupAttr('LizenzZuschuss1')
				if not _LizenzZuschuss1Attr.shouldRegisterChanges():
					_LizenzZuschuss1Attr = 0
			if _LizenzZuschuss1Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['LizenzZuschuss1'] = _LizenzZuschuss1Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Lizenz2(self):
		return self._Lizenz2

	def setLizenz2(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Lizenz2
		self._Lizenz2 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _Lizenz2Attr
			if _Lizenz2Attr is None:
				_Lizenz2Attr = self.klass().lookupAttr('Lizenz2')
				if not _Lizenz2Attr.shouldRegisterChanges():
					_Lizenz2Attr = 0
			if _Lizenz2Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Lizenz2'] = _Lizenz2Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def LizenzNr2(self):
		return self._LizenzNr2

	def setLizenzNr2(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._LizenzNr2
		self._LizenzNr2 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _LizenzNr2Attr
			if _LizenzNr2Attr is None:
				_LizenzNr2Attr = self.klass().lookupAttr('LizenzNr2')
				if not _LizenzNr2Attr.shouldRegisterChanges():
					_LizenzNr2Attr = 0
			if _LizenzNr2Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['LizenzNr2'] = _LizenzNr2Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def LizenzBis2(self):
		return self._LizenzBis2

	def setLizenzBis2(self, value):
		# have DateTime
		if value is not None:
			if type(value) is not DateTime.DateTimeType:
				raise TypeError, 'expecting date type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._LizenzBis2
		self._LizenzBis2 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _LizenzBis2Attr
			if _LizenzBis2Attr is None:
				_LizenzBis2Attr = self.klass().lookupAttr('LizenzBis2')
				if not _LizenzBis2Attr.shouldRegisterChanges():
					_LizenzBis2Attr = 0
			if _LizenzBis2Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['LizenzBis2'] = _LizenzBis2Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def LizenzZuschuss2(self):
		return self._LizenzZuschuss2

	def setLizenzZuschuss2(self, value):
		if value is not None:
			if type(value) in (types.IntType, types.LongType):
				value = float(value)
			elif type(value) is not types.FloatType:
				raise TypeError, 'expecting float type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._LizenzZuschuss2
		self._LizenzZuschuss2 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _LizenzZuschuss2Attr
			if _LizenzZuschuss2Attr is None:
				_LizenzZuschuss2Attr = self.klass().lookupAttr('LizenzZuschuss2')
				if not _LizenzZuschuss2Attr.shouldRegisterChanges():
					_LizenzZuschuss2Attr = 0
			if _LizenzZuschuss2Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['LizenzZuschuss2'] = _LizenzZuschuss2Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Lizenz3(self):
		return self._Lizenz3

	def setLizenz3(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Lizenz3
		self._Lizenz3 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _Lizenz3Attr
			if _Lizenz3Attr is None:
				_Lizenz3Attr = self.klass().lookupAttr('Lizenz3')
				if not _Lizenz3Attr.shouldRegisterChanges():
					_Lizenz3Attr = 0
			if _Lizenz3Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Lizenz3'] = _Lizenz3Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def LizenzNr3(self):
		return self._LizenzNr3

	def setLizenzNr3(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._LizenzNr3
		self._LizenzNr3 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _LizenzNr3Attr
			if _LizenzNr3Attr is None:
				_LizenzNr3Attr = self.klass().lookupAttr('LizenzNr3')
				if not _LizenzNr3Attr.shouldRegisterChanges():
					_LizenzNr3Attr = 0
			if _LizenzNr3Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['LizenzNr3'] = _LizenzNr3Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def LizenzBis3(self):
		return self._LizenzBis3

	def setLizenzBis3(self, value):
		# have DateTime
		if value is not None:
			if type(value) is not DateTime.DateTimeType:
				raise TypeError, 'expecting date type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._LizenzBis3
		self._LizenzBis3 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _LizenzBis3Attr
			if _LizenzBis3Attr is None:
				_LizenzBis3Attr = self.klass().lookupAttr('LizenzBis3')
				if not _LizenzBis3Attr.shouldRegisterChanges():
					_LizenzBis3Attr = 0
			if _LizenzBis3Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['LizenzBis3'] = _LizenzBis3Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def LizenzZuschuss3(self):
		return self._LizenzZuschuss3

	def setLizenzZuschuss3(self, value):
		if value is not None:
			if type(value) in (types.IntType, types.LongType):
				value = float(value)
			elif type(value) is not types.FloatType:
				raise TypeError, 'expecting float type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._LizenzZuschuss3
		self._LizenzZuschuss3 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _LizenzZuschuss3Attr
			if _LizenzZuschuss3Attr is None:
				_LizenzZuschuss3Attr = self.klass().lookupAttr('LizenzZuschuss3')
				if not _LizenzZuschuss3Attr.shouldRegisterChanges():
					_LizenzZuschuss3Attr = 0
			if _LizenzZuschuss3Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['LizenzZuschuss3'] = _LizenzZuschuss3Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Lizenz4(self):
		return self._Lizenz4

	def setLizenz4(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Lizenz4
		self._Lizenz4 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _Lizenz4Attr
			if _Lizenz4Attr is None:
				_Lizenz4Attr = self.klass().lookupAttr('Lizenz4')
				if not _Lizenz4Attr.shouldRegisterChanges():
					_Lizenz4Attr = 0
			if _Lizenz4Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Lizenz4'] = _Lizenz4Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def LizenzNr4(self):
		return self._LizenzNr4

	def setLizenzNr4(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._LizenzNr4
		self._LizenzNr4 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _LizenzNr4Attr
			if _LizenzNr4Attr is None:
				_LizenzNr4Attr = self.klass().lookupAttr('LizenzNr4')
				if not _LizenzNr4Attr.shouldRegisterChanges():
					_LizenzNr4Attr = 0
			if _LizenzNr4Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['LizenzNr4'] = _LizenzNr4Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def LizenzBis4(self):
		return self._LizenzBis4

	def setLizenzBis4(self, value):
		# have DateTime
		if value is not None:
			if type(value) is not DateTime.DateTimeType:
				raise TypeError, 'expecting date type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._LizenzBis4
		self._LizenzBis4 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _LizenzBis4Attr
			if _LizenzBis4Attr is None:
				_LizenzBis4Attr = self.klass().lookupAttr('LizenzBis4')
				if not _LizenzBis4Attr.shouldRegisterChanges():
					_LizenzBis4Attr = 0
			if _LizenzBis4Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['LizenzBis4'] = _LizenzBis4Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def LizenzZuschuss4(self):
		return self._LizenzZuschuss4

	def setLizenzZuschuss4(self, value):
		if value is not None:
			if type(value) in (types.IntType, types.LongType):
				value = float(value)
			elif type(value) is not types.FloatType:
				raise TypeError, 'expecting float type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._LizenzZuschuss4
		self._LizenzZuschuss4 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _LizenzZuschuss4Attr
			if _LizenzZuschuss4Attr is None:
				_LizenzZuschuss4Attr = self.klass().lookupAttr('LizenzZuschuss4')
				if not _LizenzZuschuss4Attr.shouldRegisterChanges():
					_LizenzZuschuss4Attr = 0
			if _LizenzZuschuss4Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['LizenzZuschuss4'] = _LizenzZuschuss4Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Lizenz5(self):
		return self._Lizenz5

	def setLizenz5(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Lizenz5
		self._Lizenz5 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _Lizenz5Attr
			if _Lizenz5Attr is None:
				_Lizenz5Attr = self.klass().lookupAttr('Lizenz5')
				if not _Lizenz5Attr.shouldRegisterChanges():
					_Lizenz5Attr = 0
			if _Lizenz5Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Lizenz5'] = _Lizenz5Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def LizenzNr5(self):
		return self._LizenzNr5

	def setLizenzNr5(self, value):
		# have DateTime
		if value is not None:
			if type(value) is not DateTime.DateTimeType:
				raise TypeError, 'expecting date type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._LizenzNr5
		self._LizenzNr5 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _LizenzNr5Attr
			if _LizenzNr5Attr is None:
				_LizenzNr5Attr = self.klass().lookupAttr('LizenzNr5')
				if not _LizenzNr5Attr.shouldRegisterChanges():
					_LizenzNr5Attr = 0
			if _LizenzNr5Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['LizenzNr5'] = _LizenzNr5Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def LizenzBis5(self):
		return self._LizenzBis5

	def setLizenzBis5(self, value):
		# have DateTime
		if value is not None:
			if type(value) is not DateTime.DateTimeType:
				raise TypeError, 'expecting date type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._LizenzBis5
		self._LizenzBis5 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _LizenzBis5Attr
			if _LizenzBis5Attr is None:
				_LizenzBis5Attr = self.klass().lookupAttr('LizenzBis5')
				if not _LizenzBis5Attr.shouldRegisterChanges():
					_LizenzBis5Attr = 0
			if _LizenzBis5Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['LizenzBis5'] = _LizenzBis5Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def LizenzZuschuss5(self):
		return self._LizenzZuschuss5

	def setLizenzZuschuss5(self, value):
		if value is not None:
			if type(value) in (types.IntType, types.LongType):
				value = float(value)
			elif type(value) is not types.FloatType:
				raise TypeError, 'expecting float type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._LizenzZuschuss5
		self._LizenzZuschuss5 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _LizenzZuschuss5Attr
			if _LizenzZuschuss5Attr is None:
				_LizenzZuschuss5Attr = self.klass().lookupAttr('LizenzZuschuss5')
				if not _LizenzZuschuss5Attr.shouldRegisterChanges():
					_LizenzZuschuss5Attr = 0
			if _LizenzZuschuss5Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['LizenzZuschuss5'] = _LizenzZuschuss5Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Lizenz6(self):
		return self._Lizenz6

	def setLizenz6(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Lizenz6
		self._Lizenz6 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _Lizenz6Attr
			if _Lizenz6Attr is None:
				_Lizenz6Attr = self.klass().lookupAttr('Lizenz6')
				if not _Lizenz6Attr.shouldRegisterChanges():
					_Lizenz6Attr = 0
			if _Lizenz6Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Lizenz6'] = _Lizenz6Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def LizenzNr6(self):
		return self._LizenzNr6

	def setLizenzNr6(self, value):
		# have DateTime
		if value is not None:
			if type(value) is not DateTime.DateTimeType:
				raise TypeError, 'expecting date type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._LizenzNr6
		self._LizenzNr6 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _LizenzNr6Attr
			if _LizenzNr6Attr is None:
				_LizenzNr6Attr = self.klass().lookupAttr('LizenzNr6')
				if not _LizenzNr6Attr.shouldRegisterChanges():
					_LizenzNr6Attr = 0
			if _LizenzNr6Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['LizenzNr6'] = _LizenzNr6Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def LizenzBis6(self):
		return self._LizenzBis6

	def setLizenzBis6(self, value):
		# have DateTime
		if value is not None:
			if type(value) is not DateTime.DateTimeType:
				raise TypeError, 'expecting date type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._LizenzBis6
		self._LizenzBis6 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _LizenzBis6Attr
			if _LizenzBis6Attr is None:
				_LizenzBis6Attr = self.klass().lookupAttr('LizenzBis6')
				if not _LizenzBis6Attr.shouldRegisterChanges():
					_LizenzBis6Attr = 0
			if _LizenzBis6Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['LizenzBis6'] = _LizenzBis6Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def LizenzZuschuss6(self):
		return self._LizenzZuschuss6

	def setLizenzZuschuss6(self, value):
		if value is not None:
			if type(value) in (types.IntType, types.LongType):
				value = float(value)
			elif type(value) is not types.FloatType:
				raise TypeError, 'expecting float type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._LizenzZuschuss6
		self._LizenzZuschuss6 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _LizenzZuschuss6Attr
			if _LizenzZuschuss6Attr is None:
				_LizenzZuschuss6Attr = self.klass().lookupAttr('LizenzZuschuss6')
				if not _LizenzZuschuss6Attr.shouldRegisterChanges():
					_LizenzZuschuss6Attr = 0
			if _LizenzZuschuss6Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['LizenzZuschuss6'] = _LizenzZuschuss6Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Fortbildungen(self):
		return self._Fortbildungen

	def setFortbildungen(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Fortbildungen
		self._Fortbildungen = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _FortbildungenAttr
			if _FortbildungenAttr is None:
				_FortbildungenAttr = self.klass().lookupAttr('Fortbildungen')
				if not _FortbildungenAttr.shouldRegisterChanges():
					_FortbildungenAttr = 0
			if _FortbildungenAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Fortbildungen'] = _FortbildungenAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Honorar1(self):
		return self._Honorar1

	def setHonorar1(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Honorar1
		self._Honorar1 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _Honorar1Attr
			if _Honorar1Attr is None:
				_Honorar1Attr = self.klass().lookupAttr('Honorar1')
				if not _Honorar1Attr.shouldRegisterChanges():
					_Honorar1Attr = 0
			if _Honorar1Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Honorar1'] = _Honorar1Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def HonorarBetrag1(self):
		return self._HonorarBetrag1

	def setHonorarBetrag1(self, value):
		if value is not None:
			if type(value) in (types.IntType, types.LongType):
				value = float(value)
			elif type(value) is not types.FloatType:
				raise TypeError, 'expecting float type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._HonorarBetrag1
		self._HonorarBetrag1 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _HonorarBetrag1Attr
			if _HonorarBetrag1Attr is None:
				_HonorarBetrag1Attr = self.klass().lookupAttr('HonorarBetrag1')
				if not _HonorarBetrag1Attr.shouldRegisterChanges():
					_HonorarBetrag1Attr = 0
			if _HonorarBetrag1Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['HonorarBetrag1'] = _HonorarBetrag1Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Honorar2(self):
		return self._Honorar2

	def setHonorar2(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Honorar2
		self._Honorar2 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _Honorar2Attr
			if _Honorar2Attr is None:
				_Honorar2Attr = self.klass().lookupAttr('Honorar2')
				if not _Honorar2Attr.shouldRegisterChanges():
					_Honorar2Attr = 0
			if _Honorar2Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Honorar2'] = _Honorar2Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def HonorarBetrag2(self):
		return self._HonorarBetrag2

	def setHonorarBetrag2(self, value):
		if value is not None:
			if type(value) in (types.IntType, types.LongType):
				value = float(value)
			elif type(value) is not types.FloatType:
				raise TypeError, 'expecting float type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._HonorarBetrag2
		self._HonorarBetrag2 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _HonorarBetrag2Attr
			if _HonorarBetrag2Attr is None:
				_HonorarBetrag2Attr = self.klass().lookupAttr('HonorarBetrag2')
				if not _HonorarBetrag2Attr.shouldRegisterChanges():
					_HonorarBetrag2Attr = 0
			if _HonorarBetrag2Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['HonorarBetrag2'] = _HonorarBetrag2Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Honorar3(self):
		return self._Honorar3

	def setHonorar3(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Honorar3
		self._Honorar3 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _Honorar3Attr
			if _Honorar3Attr is None:
				_Honorar3Attr = self.klass().lookupAttr('Honorar3')
				if not _Honorar3Attr.shouldRegisterChanges():
					_Honorar3Attr = 0
			if _Honorar3Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Honorar3'] = _Honorar3Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def HonorarBetrag3(self):
		return self._HonorarBetrag3

	def setHonorarBetrag3(self, value):
		if value is not None:
			if type(value) in (types.IntType, types.LongType):
				value = float(value)
			elif type(value) is not types.FloatType:
				raise TypeError, 'expecting float type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._HonorarBetrag3
		self._HonorarBetrag3 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _HonorarBetrag3Attr
			if _HonorarBetrag3Attr is None:
				_HonorarBetrag3Attr = self.klass().lookupAttr('HonorarBetrag3')
				if not _HonorarBetrag3Attr.shouldRegisterChanges():
					_HonorarBetrag3Attr = 0
			if _HonorarBetrag3Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['HonorarBetrag3'] = _HonorarBetrag3Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Honorar4(self):
		return self._Honorar4

	def setHonorar4(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Honorar4
		self._Honorar4 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _Honorar4Attr
			if _Honorar4Attr is None:
				_Honorar4Attr = self.klass().lookupAttr('Honorar4')
				if not _Honorar4Attr.shouldRegisterChanges():
					_Honorar4Attr = 0
			if _Honorar4Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Honorar4'] = _Honorar4Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def HonorarBetrag4(self):
		return self._HonorarBetrag4

	def setHonorarBetrag4(self, value):
		if value is not None:
			if type(value) in (types.IntType, types.LongType):
				value = float(value)
			elif type(value) is not types.FloatType:
				raise TypeError, 'expecting float type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._HonorarBetrag4
		self._HonorarBetrag4 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _HonorarBetrag4Attr
			if _HonorarBetrag4Attr is None:
				_HonorarBetrag4Attr = self.klass().lookupAttr('HonorarBetrag4')
				if not _HonorarBetrag4Attr.shouldRegisterChanges():
					_HonorarBetrag4Attr = 0
			if _HonorarBetrag4Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['HonorarBetrag4'] = _HonorarBetrag4Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Honorar5(self):
		return self._Honorar5

	def setHonorar5(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Honorar5
		self._Honorar5 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _Honorar5Attr
			if _Honorar5Attr is None:
				_Honorar5Attr = self.klass().lookupAttr('Honorar5')
				if not _Honorar5Attr.shouldRegisterChanges():
					_Honorar5Attr = 0
			if _Honorar5Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Honorar5'] = _Honorar5Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def HonorarBetrag5(self):
		return self._HonorarBetrag5

	def setHonorarBetrag5(self, value):
		if value is not None:
			if type(value) in (types.IntType, types.LongType):
				value = float(value)
			elif type(value) is not types.FloatType:
				raise TypeError, 'expecting float type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._HonorarBetrag5
		self._HonorarBetrag5 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _HonorarBetrag5Attr
			if _HonorarBetrag5Attr is None:
				_HonorarBetrag5Attr = self.klass().lookupAttr('HonorarBetrag5')
				if not _HonorarBetrag5Attr.shouldRegisterChanges():
					_HonorarBetrag5Attr = 0
			if _HonorarBetrag5Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['HonorarBetrag5'] = _HonorarBetrag5Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Honorar6(self):
		return self._Honorar6

	def setHonorar6(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Honorar6
		self._Honorar6 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _Honorar6Attr
			if _Honorar6Attr is None:
				_Honorar6Attr = self.klass().lookupAttr('Honorar6')
				if not _Honorar6Attr.shouldRegisterChanges():
					_Honorar6Attr = 0
			if _Honorar6Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Honorar6'] = _Honorar6Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def HonorarBetrag6(self):
		return self._HonorarBetrag6

	def setHonorarBetrag6(self, value):
		if value is not None:
			if type(value) in (types.IntType, types.LongType):
				value = float(value)
			elif type(value) is not types.FloatType:
				raise TypeError, 'expecting float type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._HonorarBetrag6
		self._HonorarBetrag6 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _HonorarBetrag6Attr
			if _HonorarBetrag6Attr is None:
				_HonorarBetrag6Attr = self.klass().lookupAttr('HonorarBetrag6')
				if not _HonorarBetrag6Attr.shouldRegisterChanges():
					_HonorarBetrag6Attr = 0
			if _HonorarBetrag6Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['HonorarBetrag6'] = _HonorarBetrag6Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Training1(self):
		return self._Training1

	def setTraining1(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Training1
		self._Training1 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _Training1Attr
			if _Training1Attr is None:
				_Training1Attr = self.klass().lookupAttr('Training1')
				if not _Training1Attr.shouldRegisterChanges():
					_Training1Attr = 0
			if _Training1Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Training1'] = _Training1Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def TrainingOrt1(self):
		return self._TrainingOrt1

	def setTrainingOrt1(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._TrainingOrt1
		self._TrainingOrt1 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _TrainingOrt1Attr
			if _TrainingOrt1Attr is None:
				_TrainingOrt1Attr = self.klass().lookupAttr('TrainingOrt1')
				if not _TrainingOrt1Attr.shouldRegisterChanges():
					_TrainingOrt1Attr = 0
			if _TrainingOrt1Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['TrainingOrt1'] = _TrainingOrt1Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def TrainingTermin1(self):
		return self._TrainingTermin1

	def setTrainingTermin1(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._TrainingTermin1
		self._TrainingTermin1 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _TrainingTermin1Attr
			if _TrainingTermin1Attr is None:
				_TrainingTermin1Attr = self.klass().lookupAttr('TrainingTermin1')
				if not _TrainingTermin1Attr.shouldRegisterChanges():
					_TrainingTermin1Attr = 0
			if _TrainingTermin1Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['TrainingTermin1'] = _TrainingTermin1Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Training2(self):
		return self._Training2

	def setTraining2(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Training2
		self._Training2 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _Training2Attr
			if _Training2Attr is None:
				_Training2Attr = self.klass().lookupAttr('Training2')
				if not _Training2Attr.shouldRegisterChanges():
					_Training2Attr = 0
			if _Training2Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Training2'] = _Training2Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def TrainingOrt2(self):
		return self._TrainingOrt2

	def setTrainingOrt2(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._TrainingOrt2
		self._TrainingOrt2 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _TrainingOrt2Attr
			if _TrainingOrt2Attr is None:
				_TrainingOrt2Attr = self.klass().lookupAttr('TrainingOrt2')
				if not _TrainingOrt2Attr.shouldRegisterChanges():
					_TrainingOrt2Attr = 0
			if _TrainingOrt2Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['TrainingOrt2'] = _TrainingOrt2Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def TrainingTermin2(self):
		return self._TrainingTermin2

	def setTrainingTermin2(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._TrainingTermin2
		self._TrainingTermin2 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _TrainingTermin2Attr
			if _TrainingTermin2Attr is None:
				_TrainingTermin2Attr = self.klass().lookupAttr('TrainingTermin2')
				if not _TrainingTermin2Attr.shouldRegisterChanges():
					_TrainingTermin2Attr = 0
			if _TrainingTermin2Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['TrainingTermin2'] = _TrainingTermin2Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Training3(self):
		return self._Training3

	def setTraining3(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Training3
		self._Training3 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _Training3Attr
			if _Training3Attr is None:
				_Training3Attr = self.klass().lookupAttr('Training3')
				if not _Training3Attr.shouldRegisterChanges():
					_Training3Attr = 0
			if _Training3Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Training3'] = _Training3Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def TrainingOrt3(self):
		return self._TrainingOrt3

	def setTrainingOrt3(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._TrainingOrt3
		self._TrainingOrt3 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _TrainingOrt3Attr
			if _TrainingOrt3Attr is None:
				_TrainingOrt3Attr = self.klass().lookupAttr('TrainingOrt3')
				if not _TrainingOrt3Attr.shouldRegisterChanges():
					_TrainingOrt3Attr = 0
			if _TrainingOrt3Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['TrainingOrt3'] = _TrainingOrt3Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def TrainingTermin3(self):
		return self._TrainingTermin3

	def setTrainingTermin3(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._TrainingTermin3
		self._TrainingTermin3 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _TrainingTermin3Attr
			if _TrainingTermin3Attr is None:
				_TrainingTermin3Attr = self.klass().lookupAttr('TrainingTermin3')
				if not _TrainingTermin3Attr.shouldRegisterChanges():
					_TrainingTermin3Attr = 0
			if _TrainingTermin3Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['TrainingTermin3'] = _TrainingTermin3Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Training4(self):
		return self._Training4

	def setTraining4(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Training4
		self._Training4 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _Training4Attr
			if _Training4Attr is None:
				_Training4Attr = self.klass().lookupAttr('Training4')
				if not _Training4Attr.shouldRegisterChanges():
					_Training4Attr = 0
			if _Training4Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Training4'] = _Training4Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def TrainingOrt4(self):
		return self._TrainingOrt4

	def setTrainingOrt4(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._TrainingOrt4
		self._TrainingOrt4 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _TrainingOrt4Attr
			if _TrainingOrt4Attr is None:
				_TrainingOrt4Attr = self.klass().lookupAttr('TrainingOrt4')
				if not _TrainingOrt4Attr.shouldRegisterChanges():
					_TrainingOrt4Attr = 0
			if _TrainingOrt4Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['TrainingOrt4'] = _TrainingOrt4Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def TrainingTermin4(self):
		return self._TrainingTermin4

	def setTrainingTermin4(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._TrainingTermin4
		self._TrainingTermin4 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _TrainingTermin4Attr
			if _TrainingTermin4Attr is None:
				_TrainingTermin4Attr = self.klass().lookupAttr('TrainingTermin4')
				if not _TrainingTermin4Attr.shouldRegisterChanges():
					_TrainingTermin4Attr = 0
			if _TrainingTermin4Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['TrainingTermin4'] = _TrainingTermin4Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Training5(self):
		return self._Training5

	def setTraining5(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Training5
		self._Training5 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _Training5Attr
			if _Training5Attr is None:
				_Training5Attr = self.klass().lookupAttr('Training5')
				if not _Training5Attr.shouldRegisterChanges():
					_Training5Attr = 0
			if _Training5Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Training5'] = _Training5Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def TrainingOrt5(self):
		return self._TrainingOrt5

	def setTrainingOrt5(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._TrainingOrt5
		self._TrainingOrt5 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _TrainingOrt5Attr
			if _TrainingOrt5Attr is None:
				_TrainingOrt5Attr = self.klass().lookupAttr('TrainingOrt5')
				if not _TrainingOrt5Attr.shouldRegisterChanges():
					_TrainingOrt5Attr = 0
			if _TrainingOrt5Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['TrainingOrt5'] = _TrainingOrt5Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def TrainingTermin5(self):
		return self._TrainingTermin5

	def setTrainingTermin5(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._TrainingTermin5
		self._TrainingTermin5 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _TrainingTermin5Attr
			if _TrainingTermin5Attr is None:
				_TrainingTermin5Attr = self.klass().lookupAttr('TrainingTermin5')
				if not _TrainingTermin5Attr.shouldRegisterChanges():
					_TrainingTermin5Attr = 0
			if _TrainingTermin5Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['TrainingTermin5'] = _TrainingTermin5Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Training6(self):
		return self._Training6

	def setTraining6(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Training6
		self._Training6 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _Training6Attr
			if _Training6Attr is None:
				_Training6Attr = self.klass().lookupAttr('Training6')
				if not _Training6Attr.shouldRegisterChanges():
					_Training6Attr = 0
			if _Training6Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Training6'] = _Training6Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def TrainingOrt6(self):
		return self._TrainingOrt6

	def setTrainingOrt6(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._TrainingOrt6
		self._TrainingOrt6 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _TrainingOrt6Attr
			if _TrainingOrt6Attr is None:
				_TrainingOrt6Attr = self.klass().lookupAttr('TrainingOrt6')
				if not _TrainingOrt6Attr.shouldRegisterChanges():
					_TrainingOrt6Attr = 0
			if _TrainingOrt6Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['TrainingOrt6'] = _TrainingOrt6Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def TrainingTermin6(self):
		return self._TrainingTermin6

	def setTrainingTermin6(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._TrainingTermin6
		self._TrainingTermin6 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _TrainingTermin6Attr
			if _TrainingTermin6Attr is None:
				_TrainingTermin6Attr = self.klass().lookupAttr('TrainingTermin6')
				if not _TrainingTermin6Attr.shouldRegisterChanges():
					_TrainingTermin6Attr = 0
			if _TrainingTermin6Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['TrainingTermin6'] = _TrainingTermin6Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Training7(self):
		return self._Training7

	def setTraining7(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Training7
		self._Training7 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _Training7Attr
			if _Training7Attr is None:
				_Training7Attr = self.klass().lookupAttr('Training7')
				if not _Training7Attr.shouldRegisterChanges():
					_Training7Attr = 0
			if _Training7Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Training7'] = _Training7Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def TrainingOrt7(self):
		return self._TrainingOrt7

	def setTrainingOrt7(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._TrainingOrt7
		self._TrainingOrt7 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _TrainingOrt7Attr
			if _TrainingOrt7Attr is None:
				_TrainingOrt7Attr = self.klass().lookupAttr('TrainingOrt7')
				if not _TrainingOrt7Attr.shouldRegisterChanges():
					_TrainingOrt7Attr = 0
			if _TrainingOrt7Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['TrainingOrt7'] = _TrainingOrt7Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def TrainingTermin7(self):
		return self._TrainingTermin7

	def setTrainingTermin7(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._TrainingTermin7
		self._TrainingTermin7 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _TrainingTermin7Attr
			if _TrainingTermin7Attr is None:
				_TrainingTermin7Attr = self.klass().lookupAttr('TrainingTermin7')
				if not _TrainingTermin7Attr.shouldRegisterChanges():
					_TrainingTermin7Attr = 0
			if _TrainingTermin7Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['TrainingTermin7'] = _TrainingTermin7Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Training8(self):
		return self._Training8

	def setTraining8(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Training8
		self._Training8 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _Training8Attr
			if _Training8Attr is None:
				_Training8Attr = self.klass().lookupAttr('Training8')
				if not _Training8Attr.shouldRegisterChanges():
					_Training8Attr = 0
			if _Training8Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Training8'] = _Training8Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def TrainingOrt8(self):
		return self._TrainingOrt8

	def setTrainingOrt8(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._TrainingOrt8
		self._TrainingOrt8 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _TrainingOrt8Attr
			if _TrainingOrt8Attr is None:
				_TrainingOrt8Attr = self.klass().lookupAttr('TrainingOrt8')
				if not _TrainingOrt8Attr.shouldRegisterChanges():
					_TrainingOrt8Attr = 0
			if _TrainingOrt8Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['TrainingOrt8'] = _TrainingOrt8Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def TrainingTermin8(self):
		return self._TrainingTermin8

	def setTrainingTermin8(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._TrainingTermin8
		self._TrainingTermin8 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _TrainingTermin8Attr
			if _TrainingTermin8Attr is None:
				_TrainingTermin8Attr = self.klass().lookupAttr('TrainingTermin8')
				if not _TrainingTermin8Attr.shouldRegisterChanges():
					_TrainingTermin8Attr = 0
			if _TrainingTermin8Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['TrainingTermin8'] = _TrainingTermin8Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Training9(self):
		return self._Training9

	def setTraining9(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Training9
		self._Training9 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _Training9Attr
			if _Training9Attr is None:
				_Training9Attr = self.klass().lookupAttr('Training9')
				if not _Training9Attr.shouldRegisterChanges():
					_Training9Attr = 0
			if _Training9Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Training9'] = _Training9Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def TrainingOrt9(self):
		return self._TrainingOrt9

	def setTrainingOrt9(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._TrainingOrt9
		self._TrainingOrt9 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _TrainingOrt9Attr
			if _TrainingOrt9Attr is None:
				_TrainingOrt9Attr = self.klass().lookupAttr('TrainingOrt9')
				if not _TrainingOrt9Attr.shouldRegisterChanges():
					_TrainingOrt9Attr = 0
			if _TrainingOrt9Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['TrainingOrt9'] = _TrainingOrt9Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def TrainingTermin9(self):
		return self._TrainingTermin9

	def setTrainingTermin9(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._TrainingTermin9
		self._TrainingTermin9 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _TrainingTermin9Attr
			if _TrainingTermin9Attr is None:
				_TrainingTermin9Attr = self.klass().lookupAttr('TrainingTermin9')
				if not _TrainingTermin9Attr.shouldRegisterChanges():
					_TrainingTermin9Attr = 0
			if _TrainingTermin9Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['TrainingTermin9'] = _TrainingTermin9Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Training10(self):
		return self._Training10

	def setTraining10(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Training10
		self._Training10 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _Training10Attr
			if _Training10Attr is None:
				_Training10Attr = self.klass().lookupAttr('Training10')
				if not _Training10Attr.shouldRegisterChanges():
					_Training10Attr = 0
			if _Training10Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Training10'] = _Training10Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def TrainingOrt10(self):
		return self._TrainingOrt10

	def setTrainingOrt10(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._TrainingOrt10
		self._TrainingOrt10 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _TrainingOrt10Attr
			if _TrainingOrt10Attr is None:
				_TrainingOrt10Attr = self.klass().lookupAttr('TrainingOrt10')
				if not _TrainingOrt10Attr.shouldRegisterChanges():
					_TrainingOrt10Attr = 0
			if _TrainingOrt10Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['TrainingOrt10'] = _TrainingOrt10Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def TrainingTermin10(self):
		return self._TrainingTermin10

	def setTrainingTermin10(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._TrainingTermin10
		self._TrainingTermin10 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _TrainingTermin10Attr
			if _TrainingTermin10Attr is None:
				_TrainingTermin10Attr = self.klass().lookupAttr('TrainingTermin10')
				if not _TrainingTermin10Attr.shouldRegisterChanges():
					_TrainingTermin10Attr = 0
			if _TrainingTermin10Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['TrainingTermin10'] = _TrainingTermin10Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Fehlercode(self):
		return self._Fehlercode

	def setFehlercode(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Fehlercode
		self._Fehlercode = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _FehlercodeAttr
			if _FehlercodeAttr is None:
				_FehlercodeAttr = self.klass().lookupAttr('Fehlercode')
				if not _FehlercodeAttr.shouldRegisterChanges():
					_FehlercodeAttr = 0
			if _FehlercodeAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Fehlercode'] = _FehlercodeAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def changedOn(self):
		return self._changedOn

	def setChangedOn(self, value):
		assert value is not None
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._changedOn
		self._changedOn = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _changedOnAttr
			if _changedOnAttr is None:
				_changedOnAttr = self.klass().lookupAttr('changedOn')
				if not _changedOnAttr.shouldRegisterChanges():
					_changedOnAttr = 0
			if _changedOnAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['changedOn'] = _changedOnAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def changedBy(self):
		return self._changedBy

	def setChangedBy(self, value):
		assert value is not None
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._changedBy
		self._changedBy = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _changedByAttr
			if _changedByAttr is None:
				_changedByAttr = self.klass().lookupAttr('changedBy')
				if not _changedByAttr.shouldRegisterChanges():
					_changedByAttr = 0
			if _changedByAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['changedBy'] = _changedByAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def changedAt(self):
		return self._changedAt

	def setChangedAt(self, value):
		assert value is not None
		# have DateTime
		if value is not None:
			if type(value) is not DateTime.DateTimeType:
				raise TypeError, 'expecting datetime type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._changedAt
		self._changedAt = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _changedAtAttr
			if _changedAtAttr is None:
				_changedAtAttr = self.klass().lookupAttr('changedAt')
				if not _changedAtAttr.shouldRegisterChanges():
					_changedAtAttr = 0
			if _changedAtAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['changedAt'] = _changedAtAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

