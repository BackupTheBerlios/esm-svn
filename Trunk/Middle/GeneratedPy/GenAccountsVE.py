'''
GenAccountsVE.py
Wed May 11 17:17:20 2005
Generated by MiddleKit.
'''

# MK attribute caches for setFoo() methods
_IDAttr = None
_VendorNrAttr = None
_FirmaAttr = None
_VornameAttr = None
_NachnameAttr = None
_TitelAttr = None
_AdresszusatzAttr = None
_StrasseAttr = None
_OrtAttr = None
_CountrycodeAttr = None
_PLZAttr = None
_TelefonPrivatAttr = None
_TelefonDienstAttr = None
_MobiltelefonAttr = None
_FAXAttr = None
_EMailAttr = None
_KontoNr1Attr = None
_BLZ1Attr = None
_Bank1Attr = None
_Kontoinhaber1Attr = None
_KontoNr2Attr = None
_BLZ2Attr = None
_Bank2Attr = None
_Kontoinhaber2Attr = None
_ErsteingabeAmAttr = None
_KommentareAttr = None
_FehlercodeAttr = None
_changedOnAttr = None
_changedByAttr = None
_changedAtAttr = None

import types
from mx import DateTime


from MiddleKit.Run.MiddleObject import MiddleObject
from types import InstanceType, LongType



class GenAccountsVE(MiddleObject):

	def __init__(self):
		MiddleObject.__init__(self)
		self._ID            = None
		self._VendorNr      = None
		self._Firma         = None
		self._Vorname       = None
		self._Nachname      = None
		self._Titel         = None
		self._Adresszusatz  = None
		self._Strasse       = None
		self._Ort           = None
		self._Countrycode   = None
		self._PLZ           = None
		self._TelefonPrivat = None
		self._TelefonDienst = None
		self._Mobiltelefon  = None
		self._FAX           = None
		self._EMail         = None
		self._KontoNr1      = None
		self._BLZ1          = None
		self._Bank1         = None
		self._Kontoinhaber1 = None
		self._KontoNr2      = None
		self._BLZ2          = None
		self._Bank2         = None
		self._Kontoinhaber2 = None
		self._ErsteingabeAm = None
		self._Kommentare    = None
		self._Fehlercode    = None
		self._changedOn     = None
		self._changedBy     = None
		self._changedAt     = None


	def ID(self):
		return self._ID

	def setID(self, value):
		assert value is not None
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._ID
		self._ID = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _IDAttr
			if _IDAttr is None:
				_IDAttr = self.klass().lookupAttr('ID')
				if not _IDAttr.shouldRegisterChanges():
					_IDAttr = 0
			if _IDAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['ID'] = _IDAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def VendorNr(self):
		return self._VendorNr

	def setVendorNr(self, value):
		assert value is not None
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._VendorNr
		self._VendorNr = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _VendorNrAttr
			if _VendorNrAttr is None:
				_VendorNrAttr = self.klass().lookupAttr('VendorNr')
				if not _VendorNrAttr.shouldRegisterChanges():
					_VendorNrAttr = 0
			if _VendorNrAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['VendorNr'] = _VendorNrAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Firma(self):
		return self._Firma

	def setFirma(self, value):
		assert value is not None
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Firma
		self._Firma = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _FirmaAttr
			if _FirmaAttr is None:
				_FirmaAttr = self.klass().lookupAttr('Firma')
				if not _FirmaAttr.shouldRegisterChanges():
					_FirmaAttr = 0
			if _FirmaAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Firma'] = _FirmaAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Vorname(self):
		return self._Vorname

	def setVorname(self, value):
		assert value is not None
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Vorname
		self._Vorname = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _VornameAttr
			if _VornameAttr is None:
				_VornameAttr = self.klass().lookupAttr('Vorname')
				if not _VornameAttr.shouldRegisterChanges():
					_VornameAttr = 0
			if _VornameAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Vorname'] = _VornameAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Nachname(self):
		return self._Nachname

	def setNachname(self, value):
		assert value is not None
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Nachname
		self._Nachname = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _NachnameAttr
			if _NachnameAttr is None:
				_NachnameAttr = self.klass().lookupAttr('Nachname')
				if not _NachnameAttr.shouldRegisterChanges():
					_NachnameAttr = 0
			if _NachnameAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Nachname'] = _NachnameAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Titel(self):
		return self._Titel

	def setTitel(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Titel
		self._Titel = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _TitelAttr
			if _TitelAttr is None:
				_TitelAttr = self.klass().lookupAttr('Titel')
				if not _TitelAttr.shouldRegisterChanges():
					_TitelAttr = 0
			if _TitelAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Titel'] = _TitelAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Adresszusatz(self):
		return self._Adresszusatz

	def setAdresszusatz(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Adresszusatz
		self._Adresszusatz = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _AdresszusatzAttr
			if _AdresszusatzAttr is None:
				_AdresszusatzAttr = self.klass().lookupAttr('Adresszusatz')
				if not _AdresszusatzAttr.shouldRegisterChanges():
					_AdresszusatzAttr = 0
			if _AdresszusatzAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Adresszusatz'] = _AdresszusatzAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Strasse(self):
		return self._Strasse

	def setStrasse(self, value):
		assert value is not None
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Strasse
		self._Strasse = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _StrasseAttr
			if _StrasseAttr is None:
				_StrasseAttr = self.klass().lookupAttr('Strasse')
				if not _StrasseAttr.shouldRegisterChanges():
					_StrasseAttr = 0
			if _StrasseAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Strasse'] = _StrasseAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Ort(self):
		return self._Ort

	def setOrt(self, value):
		assert value is not None
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Ort
		self._Ort = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _OrtAttr
			if _OrtAttr is None:
				_OrtAttr = self.klass().lookupAttr('Ort')
				if not _OrtAttr.shouldRegisterChanges():
					_OrtAttr = 0
			if _OrtAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Ort'] = _OrtAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Countrycode(self):
		return self._Countrycode

	def setCountrycode(self, value):
		assert value is not None
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Countrycode
		self._Countrycode = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _CountrycodeAttr
			if _CountrycodeAttr is None:
				_CountrycodeAttr = self.klass().lookupAttr('Countrycode')
				if not _CountrycodeAttr.shouldRegisterChanges():
					_CountrycodeAttr = 0
			if _CountrycodeAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Countrycode'] = _CountrycodeAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def PLZ(self):
		return self._PLZ

	def setPLZ(self, value):
		assert value is not None
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._PLZ
		self._PLZ = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _PLZAttr
			if _PLZAttr is None:
				_PLZAttr = self.klass().lookupAttr('PLZ')
				if not _PLZAttr.shouldRegisterChanges():
					_PLZAttr = 0
			if _PLZAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['PLZ'] = _PLZAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def TelefonPrivat(self):
		return self._TelefonPrivat

	def setTelefonPrivat(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._TelefonPrivat
		self._TelefonPrivat = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _TelefonPrivatAttr
			if _TelefonPrivatAttr is None:
				_TelefonPrivatAttr = self.klass().lookupAttr('TelefonPrivat')
				if not _TelefonPrivatAttr.shouldRegisterChanges():
					_TelefonPrivatAttr = 0
			if _TelefonPrivatAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['TelefonPrivat'] = _TelefonPrivatAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def TelefonDienst(self):
		return self._TelefonDienst

	def setTelefonDienst(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._TelefonDienst
		self._TelefonDienst = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _TelefonDienstAttr
			if _TelefonDienstAttr is None:
				_TelefonDienstAttr = self.klass().lookupAttr('TelefonDienst')
				if not _TelefonDienstAttr.shouldRegisterChanges():
					_TelefonDienstAttr = 0
			if _TelefonDienstAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['TelefonDienst'] = _TelefonDienstAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Mobiltelefon(self):
		return self._Mobiltelefon

	def setMobiltelefon(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Mobiltelefon
		self._Mobiltelefon = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _MobiltelefonAttr
			if _MobiltelefonAttr is None:
				_MobiltelefonAttr = self.klass().lookupAttr('Mobiltelefon')
				if not _MobiltelefonAttr.shouldRegisterChanges():
					_MobiltelefonAttr = 0
			if _MobiltelefonAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Mobiltelefon'] = _MobiltelefonAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def FAX(self):
		return self._FAX

	def setFAX(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._FAX
		self._FAX = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _FAXAttr
			if _FAXAttr is None:
				_FAXAttr = self.klass().lookupAttr('FAX')
				if not _FAXAttr.shouldRegisterChanges():
					_FAXAttr = 0
			if _FAXAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['FAX'] = _FAXAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def EMail(self):
		return self._EMail

	def setEMail(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._EMail
		self._EMail = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _EMailAttr
			if _EMailAttr is None:
				_EMailAttr = self.klass().lookupAttr('EMail')
				if not _EMailAttr.shouldRegisterChanges():
					_EMailAttr = 0
			if _EMailAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['EMail'] = _EMailAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def KontoNr1(self):
		return self._KontoNr1

	def setKontoNr1(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._KontoNr1
		self._KontoNr1 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _KontoNr1Attr
			if _KontoNr1Attr is None:
				_KontoNr1Attr = self.klass().lookupAttr('KontoNr1')
				if not _KontoNr1Attr.shouldRegisterChanges():
					_KontoNr1Attr = 0
			if _KontoNr1Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['KontoNr1'] = _KontoNr1Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def BLZ1(self):
		return self._BLZ1

	def setBLZ1(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._BLZ1
		self._BLZ1 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _BLZ1Attr
			if _BLZ1Attr is None:
				_BLZ1Attr = self.klass().lookupAttr('BLZ1')
				if not _BLZ1Attr.shouldRegisterChanges():
					_BLZ1Attr = 0
			if _BLZ1Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['BLZ1'] = _BLZ1Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Bank1(self):
		return self._Bank1

	def setBank1(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Bank1
		self._Bank1 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _Bank1Attr
			if _Bank1Attr is None:
				_Bank1Attr = self.klass().lookupAttr('Bank1')
				if not _Bank1Attr.shouldRegisterChanges():
					_Bank1Attr = 0
			if _Bank1Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Bank1'] = _Bank1Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Kontoinhaber1(self):
		return self._Kontoinhaber1

	def setKontoinhaber1(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Kontoinhaber1
		self._Kontoinhaber1 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _Kontoinhaber1Attr
			if _Kontoinhaber1Attr is None:
				_Kontoinhaber1Attr = self.klass().lookupAttr('Kontoinhaber1')
				if not _Kontoinhaber1Attr.shouldRegisterChanges():
					_Kontoinhaber1Attr = 0
			if _Kontoinhaber1Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Kontoinhaber1'] = _Kontoinhaber1Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def KontoNr2(self):
		return self._KontoNr2

	def setKontoNr2(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._KontoNr2
		self._KontoNr2 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _KontoNr2Attr
			if _KontoNr2Attr is None:
				_KontoNr2Attr = self.klass().lookupAttr('KontoNr2')
				if not _KontoNr2Attr.shouldRegisterChanges():
					_KontoNr2Attr = 0
			if _KontoNr2Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['KontoNr2'] = _KontoNr2Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def BLZ2(self):
		return self._BLZ2

	def setBLZ2(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._BLZ2
		self._BLZ2 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _BLZ2Attr
			if _BLZ2Attr is None:
				_BLZ2Attr = self.klass().lookupAttr('BLZ2')
				if not _BLZ2Attr.shouldRegisterChanges():
					_BLZ2Attr = 0
			if _BLZ2Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['BLZ2'] = _BLZ2Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Bank2(self):
		return self._Bank2

	def setBank2(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Bank2
		self._Bank2 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _Bank2Attr
			if _Bank2Attr is None:
				_Bank2Attr = self.klass().lookupAttr('Bank2')
				if not _Bank2Attr.shouldRegisterChanges():
					_Bank2Attr = 0
			if _Bank2Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Bank2'] = _Bank2Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Kontoinhaber2(self):
		return self._Kontoinhaber2

	def setKontoinhaber2(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Kontoinhaber2
		self._Kontoinhaber2 = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _Kontoinhaber2Attr
			if _Kontoinhaber2Attr is None:
				_Kontoinhaber2Attr = self.klass().lookupAttr('Kontoinhaber2')
				if not _Kontoinhaber2Attr.shouldRegisterChanges():
					_Kontoinhaber2Attr = 0
			if _Kontoinhaber2Attr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Kontoinhaber2'] = _Kontoinhaber2Attr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def ErsteingabeAm(self):
		return self._ErsteingabeAm

	def setErsteingabeAm(self, value):
		assert value is not None
		# have DateTime
		if value is not None:
			if type(value) is not DateTime.DateTimeType:
				raise TypeError, 'expecting date type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._ErsteingabeAm
		self._ErsteingabeAm = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _ErsteingabeAmAttr
			if _ErsteingabeAmAttr is None:
				_ErsteingabeAmAttr = self.klass().lookupAttr('ErsteingabeAm')
				if not _ErsteingabeAmAttr.shouldRegisterChanges():
					_ErsteingabeAmAttr = 0
			if _ErsteingabeAmAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['ErsteingabeAm'] = _ErsteingabeAmAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Kommentare(self):
		return self._Kommentare

	def setKommentare(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Kommentare
		self._Kommentare = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _KommentareAttr
			if _KommentareAttr is None:
				_KommentareAttr = self.klass().lookupAttr('Kommentare')
				if not _KommentareAttr.shouldRegisterChanges():
					_KommentareAttr = 0
			if _KommentareAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Kommentare'] = _KommentareAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def Fehlercode(self):
		return self._Fehlercode

	def setFehlercode(self, value):
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._Fehlercode
		self._Fehlercode = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _FehlercodeAttr
			if _FehlercodeAttr is None:
				_FehlercodeAttr = self.klass().lookupAttr('Fehlercode')
				if not _FehlercodeAttr.shouldRegisterChanges():
					_FehlercodeAttr = 0
			if _FehlercodeAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['Fehlercode'] = _FehlercodeAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def changedOn(self):
		return self._changedOn

	def setChangedOn(self, value):
		assert value is not None
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._changedOn
		self._changedOn = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _changedOnAttr
			if _changedOnAttr is None:
				_changedOnAttr = self.klass().lookupAttr('changedOn')
				if not _changedOnAttr.shouldRegisterChanges():
					_changedOnAttr = 0
			if _changedOnAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['changedOn'] = _changedOnAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def changedBy(self):
		return self._changedBy

	def setChangedBy(self, value):
		assert value is not None
		if value is not None:
			if type(value) is not types.StringType:
				raise TypeError, 'expecting string type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._changedBy
		self._changedBy = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _changedByAttr
			if _changedByAttr is None:
				_changedByAttr = self.klass().lookupAttr('changedBy')
				if not _changedByAttr.shouldRegisterChanges():
					_changedByAttr = 0
			if _changedByAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['changedBy'] = _changedByAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

	def changedAt(self):
		return self._changedAt

	def setChangedAt(self, value):
		assert value is not None
		# have DateTime
		if value is not None:
			if type(value) is not DateTime.DateTimeType:
				raise TypeError, 'expecting datetime type, but got value %r of type %r instead' % (value, type(value))

		# set the attribute
		origValue = self._changedAt
		self._changedAt = value

		# MiddleKit machinery
		self._mk_changed = 1  # @@ original semantics, but I think this should be under "if not self._mk_initing..."
		if not self._mk_initing and self._mk_serialNum>0 and value is not origValue:
			global _changedAtAttr
			if _changedAtAttr is None:
				_changedAtAttr = self.klass().lookupAttr('changedAt')
				if not _changedAtAttr.shouldRegisterChanges():
					_changedAtAttr = 0
			if _changedAtAttr:
				# Record that it has been changed
				if self._mk_changedAttrs is None:
					self._mk_changedAttrs = {} # maps name to attribute
				self._mk_changedAttrs['changedAt'] = _changedAtAttr  # changedAttrs is a set
				# Tell ObjectStore it happened
				self._mk_store.objectChanged(self)

